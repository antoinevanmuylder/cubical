module IsoFunAlt where

import Eq

left : (A : forall i. U) ->
       (B : forall i. A@i -> U) ->
       (f : (x : A@0) -> B@0 x) -> 
       (p : (<i> (x : A@i) -> B@i x) ? f) ->
       (x : A@0) -> (x' : A ? x) -> (<i> (B@i ([x , x']@i))) ? (f x)
left A B f p x x' = t!
  where g : forall i. (x : A@i) -> B@i x
        g = [f,p]
        t : forall i. B@i ([x , x']@i)
        t = <i> g@i [x,x']@i

right : (A : forall i. U) ->
       (B : forall i. A@i -> U) ->
       (f : (x : A@0) -> B@0 x) -> 
       (q : (x : A@0) -> (x' : A ? x) -> (<i> (B@i ([x , x']@i))) ? (f x)) ->
       (<i> (x : A@i) -> B@i x) ? f
right A B f q = g!
  where g : forall i. (x : A@i) -> B@i x
        g = <i> \x -> let y : forall k. A@k
                          y = x/i
                      in [f y@0, q y@0 y!]@i


comp1 : (A : forall i. U) ->
       (B : forall i. A@i -> U) ->
       (f : (x : A@0) -> B@0 x) -> 
       (q : (x : A@0) -> (x' : A ? x) -> (<i> (B@i ([x , x']@i))) ? (f x)) ->
       Eq ((x : A@0) -> (x' : A ? x) -> (<i> (B@i ([x , x']@i))) ? (f x))
          q (left A B f (right A B f q))
comp1 A B f q Pred proof = proof

comp2 : (A : forall i. U) ->
       (B : forall i. A@i -> U) ->
       (f : (x : A@0) -> B@0 x) -> 
       (p : (<i> (x : A@i) -> B@i x) ? f) ->
       Eq ((<i> (x : A@i) -> B@i x) ? f)
          p (right A B f (left A B f p))
comp2 A B f p Pred proof = proof


-- <| f , \x -> (\y y' -> (<i> [f,p]@i [y,y']@i)!) x@0 x! |>! = p
-- 
-- <| f , \x -> (<i> [f,p]@i [x@0,x!]@i)! |>! = p
-- 
-- <| f , \x -> (<i> [f,p]@i x@i)! |>! = p
-- 
-- <| f , \x -> (<i> [f,p]@i x@i)! |> = [f , p]
-- 
-- -- missing step:  <| f , g |> = [f , p] if g x = (<i> [f,p]@i x@i)!
-- 
-- (<i> [f,p]@i x@i)! = (<i> [f,p]@i x@i)!
-- 
-- 
-- 

-- (<i> \ [i] x -> [f x@0, (<i> [f,p]@i [x@0,x!]@i)! ]@i)! == p
-- (<i> \ [i] x -> [f x@0, (<i> [f,p]@i x@i)! ]@i)! == p
-- (<i> \ [i] x -> (<i> [f,p]@i x@i)@i)! == p
-- (<i> \ [i] x -> [f,p]@i x@i)! == p
-- (<i> \ [i] x -> [f,p]@i x@i) = [(<i> \ [i] x -> [f,p]@i x@i)@0,p]
-- (<i> \ [i] x -> [f,p]@i x@i) = [\x -> f x,p]
-- \ [i] x -> [f,p]@i x@i = [\x -> f x,p]@i
-- [f,p]@i x@i = [\x -> f x,p]@i x@i
-- [f,p]@i = [\x -> f x,p]@i
-- f = \x -> f x
-- f x = f x


-- 