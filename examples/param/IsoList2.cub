module IsoList2 where

import Eq

One : U
data One = tt

List : U -> U
data List a = nil | cons (hd : a) (tl : List a)

All : (A : U) -> (P : A -> U) -> List A -> U
All A P = split
  nil -> One
  cons x xs -> ((_ : P x) * All A P xs)

-- warm up:
zip : (A : U) -> (P : A -> U) -> (xs : List A) -> All A P xs -> List ((x : A) * P x)
zip A P = split
  nil -> \ys -> nil
  cons x xs -> \ys -> cons (x , ys.1) (zip A P xs (ys.2))

right : (A : forall i. U) -> (xs : List A@0) -> (ys : All A@0 (\x -> A ? x) xs) ->  forall i. List A@i
right A =
  split
    nil -> \ys -> <i> nil
    cons x xs -> \ys -> <i> cons [x , ys.1]@i (right A xs ys.2)@i

Sig : forall i. (A : U) -> (B : A -> U) -> U
Sig = <i> \A B -> [A , Psi A B]@i

left : forall i. (A : forall i. U) -> (xs : List A@i) -> Sig@i (List A@0) (All A@0 (\x -> A ? x))
left = <i> \A -> split
  nil -> [nil , tt]@i
  cons x xs ->
    let x' : forall k. A@k
        x' = x/i
        tl : Sig@i (List A@0) (All A@0 (\x -> A ? x))
        tl = left@i A xs
        tl' : forall i. Sig@i (List A@0) (All A@0 (\x -> A ? x))
        tl' = tl/i
    in [cons x'@0 tl'@0 , (x'! , tl'!) ]@i

left' : (A : forall i. U) -> (xs : forall i. List A@i) -> forall i. Sig@i (List A@0) (All A@0 (\x -> A ? x))
left' A xs = <i> left@i A xs@i

left'' : (A : forall i. U) -> (xs : forall i. List A@i) -> (All A@0 (\x -> A ? x)) (left@0 A xs@0)
left'' A xs = (left' A xs)!


comp1 : (A : forall i. U) -> (xs : List A@0) -> (ys : All A@0 (\x -> A ? x) xs) ->  Eq (All A@0 (\x -> A ? x) xs) (left'' A (right A xs ys)) ys
comp1 A xs ys = _
