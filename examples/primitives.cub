module primitives where

primitive Id : (A : U) (a b : A) -> U

primitive refl : (A : U) (a : A) -> Id A a a

primitive inv : (A : U) (a b : A) -> Id A a b -> Id A b a

singl : (A : U) -> A -> U
singl A a = (x: A) * (Id A a x)

primitive contrSingl : (A : U) (a b : A) (p : Id A a b) ->
                       Id (singl A a) (a, refl A a) (b, p)

primitive mapOnPath : (A B : U) (f : A -> B) (a b : A)
                      (p : Id A a b) -> Id B (f a) (f b)

primitive appOnPath : (A B : U) (f g : A -> B) (a b : A)
                      (q : Id (A -> B) f g) (p : Id A a b) -> Id B (f a) (g b)

primitive IdP : (A B : U) -> Id U A B -> A -> B -> U

IdS : (A : U) (F : A -> U) (a0 a1 : A) (p : Id A a0 a1) -> F a0 -> F a1 -> U
IdS A F a0 a1 p = IdP (F a0) (F a1) (mapOnPath A U F a0 a1 p)

primitive mapOnPathD : (A : U) (F : A -> U) (f : (x : A) -> F x) (a0 a1 : A)
                       (p : Id A a0 a1) -> IdS A F a0 a1 p  (f a0) (f a1)

primitive mapOnPathS : (A : U) (F : A -> U) (C : U) (f : (x : A) -> F x -> C)
                       (a0 a1 : A) (p : Id A a0 a1) (b0 : F a0) (b1 : F a1)
                       (q : IdS A F a0 a1 p b0 b1) -> Id C (f a0 b0) (f a1 b1)

primitive funExt : (A : U) (B : A -> U) (f g : (x : A) -> B x) ->
                   ((x : A) -> Id (B x) (f x) (g x)) ->
                   Id ((y : A) -> B y) f g

primitive transport : (A B : U) -> Id U A B -> A -> B

primitive transpInv : (A B : U) -> Id U A B -> B -> A

primitive isoId : (A B : U) (f : A -> B) (g : B -> A)
	           (s : (y:B) -> Id B (f (g y)) y)
                   (t : (x:A) -> Id A (g (f x)) x) ->
                   Id U A B

id : (A : U) -> A -> A
id A a = a

primitive isoIdRef : (A : U) ->
                   Id (Id U A A) (refl U A) (isoId A A (id A) (id A) (refl A) (refl A))

-- added as an experiment

subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
subst A P a x p = transport (P a) (P x) (mapOnPath A U P a x p)

comp : (A : U) -> (a b c : A) -> Id A a b -> Id A b c -> Id A a c
comp A a b c p q = subst A (Id A a) b c q p

primitive lemSimpl : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q q' : Id A b c) ->
                       Id (Id A a c) (comp A a b c p q) (comp A a b c p q') -> Id (Id A b c) q q'

-- Transposition

and : (A B : U) -> U
and A B = (x : A) * B

pairEq : (A B:U) (a0 a1:A) (b0 b1:B) -> Id A a0 a1 -> Id B b0 b1 ->
         Id (and A B) (a0, b0) (a1, b1)
pairEq A B a0 a1 b0 b1 p q =
 appOnPath B (and A B) f0 f1 b0 b1 rem q
  where f0 : B -> and A B
        f0 y = (a0, y)
        f1 : B -> and A B
        f1 y = (a1, y)
        rem : Id (B -> and A B) f0 f1
        rem = mapOnPath A (B -> and A B) (\ x y -> (x, y)) a0 a1 p

Square : (A:U) (a0 b0 a1 b1:A) 
         (u : Id A a0 a1) (v : Id A b0 b1) (r0 : Id A a0 b0) (r1 : Id A a1 b1) -> U
Square A a0 b0 a1 b1 u v = 
 IdS (and A A) (\ z -> Id A (z.1) (z.2)) (a0,b0) (a1,b1) (pairEq A A a0 a1 b0 b1 u v)

primitive transpose : (A:U) (a0 a1:A) (u : Id A a0 a1) (b0 b1 : A) (v : Id A b0 b1)
                      (r0 : Id A a0 b0) (r1 : Id A a1 b1) ->
                      Square A a0 b0 a1 b1 u v r0 r1 -> Square A a0 a1 b0 b1 r0 r1 u v

-- IdSElim

primitive idSElim' : (A B : U) (p : Id U A B) (x : A) (y : B)
                     -> IdP A B p x y -> Id B (transport A B p x) y

idSElim : (A : U) (F : A -> U) (x y : A) (p : Id A x y) (u : F x) (v : F y) ->
            IdS A F x y p u v -> Id (F y) (subst A F x y p u) v
idSElim A F x y p u v = idSElim' (F x) (F y) (mapOnPath A U F x y p) u v
