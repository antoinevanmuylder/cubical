module mult2 where

import turn
import susp
-- import univalence
import heterogeneous
import collection
import join

idL : (x : S1) -> Id S1 (mult base x) x
idL = hsplit (\ x -> Id S1 (mult base x) x) with
       base -> refl S1 base
       loop -> rem1
         where
           triv : Id S1 base base
           triv = refl S1 base
           rem2 : Id (Id S1 base base)
                     (comp S1 base base base triv loop)
                     (comp S1 base base base loop triv)
           rem2 = compIdl S1 base base loop
           rem1 : IdS S1 (\ x -> Id S1 (mult base x) x) base base loop triv triv
           rem1 = substPathPi S1 S1 (\ x -> mult base x) (\ x -> x) base base loop triv triv rem2

-- a general Lemma about prop-valued family of type over S1

lemPropFib : (P:S1 -> U) (pP:(x:S1) -> prop (P x)) -> P base -> (x:S1) -> P x
lemPropFib P pP bP = hsplit P with
 base -> bP
 loop -> rem
  where
   rem : IdS S1 P base base loop bP bP
   rem = idSIntro S1 P base base loop bP bP
           (pP base (subst S1 P base base loop bP) bP)

isEquivMultBase : isEquiv S1 S1 (mult base)
isEquivMultBase = substInv (S1 -> S1) (isEquiv S1 S1) (mult base) (id S1) lem1 (idIsEquiv S1)
    where lem1 : Id (S1 -> S1) (mult base) (id S1)
          lem1 = funExt S1 (\ _ -> S1) (mult base) (id S1) idL

multIsEquiv : (x:S1) -> isEquiv S1 S1 (mult x)
multIsEquiv = lemPropFib (\ x -> isEquiv S1 S1 (mult x)) pP isEquivMultBase
  where 
    pP : (x :S1) -> prop (isEquiv S1 S1 (mult x))
    pP x = propIsEquiv S1 S1 (mult x)

-- a general Lemma about set-valued family of type over S1 x S1

lemSetTorus : (E : S1 -> S1 -> U) (sE : set (E base base))
              (f : (y:S1) -> E base y) (g : (x:S1) -> E x base)
              (efg : Id (E base base) (f base) (g base)) (x y:S1) -> E x y
lemSetTorus E sE f g efg = hsplit (\ x -> (y:S1) -> E x y) with
 base -> f
 loop -> lem2
   where
    F : S1 -> U
    F x = (y:S1) -> E x y

    lem1 : (y:S1) -> IdS S1 (\ x -> E x y) base base loop (f y) (f y)
    lem1 =  lemPropFib P pP bP
     where
      P : S1 -> U
      P y = IdS S1 (\ x -> E x y) base base loop (f y) (f y)

      sbE : (y : S1) -> set (E base y)
      sbE = lemPropFib (\ y -> set (E base y)) pP sE
        where pP : (y : S1) -> prop (set (E base y))
              pP y = setIsProp (E base y)

      pP : (y:S1) -> prop (P y)
      pP y = rem3
        where
          rem1 : Id U (P y) (Id (E base y) (subst S1 (\ x -> E x y) base base loop (f y)) (f y))
          rem1 = eqSubstSig S1 (\ x -> E x y) base base loop (f y) (f y)

          rem2 : prop (Id (E base y) (subst S1 (\ x -> E x y) base base loop (f y)) (f y))
          rem2 = sbE y (subst S1 (\ x -> E x y) base base loop (f y)) (f y)

          rem3 : prop (P y)
          rem3 = substInv U prop (P y) (Id (E base y) (subst S1 (\ x -> E x y) base base loop (f y)) (f y)) rem1 rem2
          
      lem2 : IdS S1 (\ x -> E x base) base base loop (g base) (g base)
      lem2 = mapOnPathD S1 (\ x -> E x base) g base base loop

      bP : P base
      bP = substInv (E base base) (\ u -> IdS S1 (\ x -> E x base) base base loop u u) (f base) (g base) efg lem2

    lem2 : IdS S1 F base base loop f f
    lem2 = funExtDep S1 S1 E base base loop f f lem1

-- S1 is a groupoid

isGroupoidS1 : groupoid S1
isGroupoidS1 = lem
 where
  lem1 : set (Id S1 base base)
  lem1 = substInv U set loopS1 Z  loopS1EqZ ZIsSet

  lem2 : (y : S1) -> set (Id S1 base y)
  lem2 = lemPropFib (\ y -> set (Id S1 base y)) (\ y -> setIsProp (Id S1 base y)) lem1

  lem : (x y : S1) -> set (Id S1 x y)
  lem = lemPropFib (\ x -> (y : S1) -> set (Id S1 x y)) pP lem2
     where 
       pP : (x:S1) -> prop ((y:S1) -> set (Id S1 x y))
       pP x = propPi S1 (\ y -> set (Id S1 x y)) (\ y -> setIsProp (Id S1 x y))

-- commutativity of mult, at last

multCom : (x y : S1) -> Id S1 (mult x y) (mult y x)
multCom = lemSetTorus E sE f g efg
  where
    E : S1 -> S1 -> U
    E x y = Id S1 (mult x y) (mult y x)

    sE : set (E base base)
    sE = isGroupoidS1 base base

    f : (y : S1) -> E base y
    f y = idL y

    g : (x : S1) -> E x base
    g x = inv S1 (mult base x) (mult x base) (idL x)

    efg : Id (E base base) (f base) (g base)
    efg = refl (E base base) (f base)

test : (x:S1) -> Id S1 (mult x base) x
test x = refl S1 x

multAssoc : (x y z : S1) -> Id S1 (mult x (mult y z)) (mult (mult x y) z)
multAssoc x = lemSetTorus E sE f g efg
 where
   E : S1 -> S1 -> U
   E y z = Id S1 (mult x (mult y z)) (mult (mult x y) z)

   sE : set (E base base)
   sE = isGroupoidS1 x x

   f : (z : S1) -> E base z
   f z = rem
     where 
        rem1 : Id S1 (mult base z) z
        rem1 = multCom base z

        rem : Id S1 (mult x (mult base z)) (mult x z)
        rem = mapOnPath S1 S1 (mult x) (mult base z) z rem1

   g : (y : S1) -> E y base
   g y = refl S1 (mult x y)

   efg : Id (E base base) (f base) (g base)
   efg = refl (E base base) (f base)

-- the inverse law

-- lemPropFib : (P:S1 -> U) (pP:(x:S1) -> prop (P x)) -> P base -> (x:S1) -> P x

lemPropRel : (P:S1 -> S1 -> U) (pP:(x y:S1) -> prop (P x y)) -> P base base -> (x y:S1) -> P x y
lemPropRel P pP bP = lemPropFib (\ x -> (y:S1) -> P x y)
                                (\ x -> propPi S1 (P x) (pP x))
                                rem
 where
   rem : (y:S1) -> P base y
   rem = lemPropFib (P base) (pP base) bP

invLaw : (x y : S1) -> 
          Id (Id S1 (mult x y) (mult x y)) (refl S1 (mult x y))
                                        (comp S1 (mult x y) (mult y x) (mult x y) (multCom x y) (multCom y x))
invLaw = lemPropRel P pP bP
 where
  P : S1 -> S1 -> U
  P x y = Id (Id S1 (mult x y) (mult x y)) (refl S1 (mult x y))
                                        (comp S1 (mult x y) (mult y x) (mult x y) (multCom x y) (multCom y x))

  pP : (x y : S1) -> prop (P x y)
  pP x y = isGroupoidS1 (mult x y) (mult x y) (refl S1 (mult x y))
                                        (comp S1 (mult x y) (mult y x) (mult x y) (multCom x y) (multCom y x))

  bP : P base base
  bP = refl (Id S1 base base) (refl S1 base)

mults : sone -> sone -> sone
mults = substInv U (\ X -> X -> X -> X) sone S1 s1EqCircle mult

test1 : sone
test1 = mults north north

test2 : sone
test2 = mults south south

-- this operation mults also should be commutative

lemSubst : (A:U) (B : A -> U) (C:(x:A) -> B x -> U) ( a b :A) (p:Id A a b) (v : B b) -> 
              C b v -> C a (substInv A B a b p v)
lemSubst A B C a = J A a (\ b p -> (v : B b) -> C b v -> C a (substInv A B a b p v)) rem
 where
   rem : (v : B a) -> C a v -> C a v
   rem v h = h

lemSubst2 : (A:U) (B B': A -> U) (C:(x:A) -> B x -> B' x -> U) ( a b :A) (p:Id A a b) (v : B b) (v':B' b) -> 
              C b v v' -> C a (substInv A B a b p v) (substInv A B' a b p v')
lemSubst2 A B B' C a = J A a (\ b p ->  (v : B b) (v':B' b) -> 
                                      C b v v' -> C a (substInv A B a b p v) (substInv A B' a b p v')) rem
 where
   rem : (v : B a) (v': B' a) -> C a v v' -> C a v v'
   rem v v' h = h

multsCom : (x y : sone) -> Id sone (mults x y) (mults y x)
multsCom = lemSubst U (\ X -> X -> X -> X) (\ X f -> (x y : X) -> Id X (f x y) (f y x))
              sone S1 s1EqCircle mult multCom

multsN : (x:sone) -> Id sone (mults x north) x
multsN = lemSubst2 U (\ X -> X -> X -> X) (\ X -> X) (\ X f a -> (x:X) -> Id X (f x a) x) 
             sone S1 s1EqCircle mult base (\ x -> refl S1 x)

test3 : Id sone (mults south south) (mults south south)
test3 = multsCom south south

test4 : Id sone (mults south north) (mults north south)
test4 = multsCom south north

test5 : Id sone (mults south north) south
test5 = multsN south

test6 : Id sone north south
test6 = multsN south

multsAssoc : (x y z : sone) ->  Id sone (mults x (mults y z)) (mults (mults x y) z)
multsAssoc = lemSubst U (\ X -> X -> X -> X) (\ X f -> (x y z : X) -> Id X (f x (f y z)) (f (f x y) z))
              sone S1 s1EqCircle mult multAssoc

test7 : Id sone north north
test7 = multsAssoc south south south

test8 : Id sone (mults south (mults north south)) (mults (mults south north) north)
test8 = multsAssoc south north south

-- test9 : Z
-- test9 = windingS (mapOnPath sone sone (\ x -> mults (mults x x) (mults x x)) north north loop2)

-- test10 : Z
-- test10 = windingS (mapOnPath sone sone (\ x -> mults x x) north north loop4)

-- inverse of mult x

-- multIsEquiv : (x:S1) -> isEquiv S1 S1 (mult x)

invMult : S1 -> S1 -> S1
invMult x y = rem1.1
 where
  rem : isContr (fiber S1 S1 (mult x) y)
  rem = multIsEquiv x y

  rem1 : fiber S1 S1 (mult x) y
  rem1 = rem.2

invMultP : (x y:S1) -> Id S1 (mult x (invMult x y)) y
invMultP x y = rem1.2
 where
  rem : isContr (fiber S1 S1 (mult x) y)
  rem = multIsEquiv x y

  rem1 : fiber S1 S1 (mult x) y
  rem1 = rem.2

testB : Id S1 (mult base (invMult base base)) base
testB = invMultP base base

-- test for invMult

test : Z
test = winding (mapOnPath S1 S1 (\ x -> invMult x base) base base loop)

invSq : S1 -> S1
invSq x = invMult x (invMult x base)

test1 : Z
test1 = winding (mapOnPath S1 S1 (\ x -> invSq (invSq (invSq x))) base base loop)

test1 : Z
test1 = winding (mapOnPath S1 S1 (\ x -> invMult x (invMult x base)) base base loop)

test2 : Z
test2 = winding (mapOnPath S1 S1 (\ x -> invMult (invMult x x) (invMult x x)) base base loop)

test3 : Z
test3 = winding (mapOnPath S1 S1 (\ x -> invMult x (mult x x)) base base loop)

multS : sone -> sone -> sone
multS = substInv U (\ X -> X -> X -> X) sone S1 s1EqCircle mult

invMultS : sone -> sone -> sone
invMultS = substInv U (\ X -> X -> X -> X) sone S1 s1EqCircle invMult

invSqS : sone -> sone
invSqS x = invMultS x (invMultS x north)

test1S : Z
test1S = windingS (mapOnPath sone sone invSqS north north loop')

-- inverse for multiplication

invS1 : S1 -> S1
invS1 = hsplit (\ _ -> S1) with
 base -> base
 loop -> inv S1 base base loop

testInv : loopS1
testInv = mapOnPath S1 S1 (\ x -> mult x (invS1 x)) base base loop

testInv1 : loopS1
testInv1 = mapOnPath S1 S1 (\ x -> mult (invS1 x) x) base base loop

compLoop : loopS1
compLoop = compS1 (inv S1 base base loop) loop

testInv2 : Id (Id S1 base base) testInv compLoop
testInv2 = refl (Id S1 base base) testInv

lemIdInv : (A:U)(a b : A)(p:Id A a b) -> Id (Id A b b) (refl A b) (comp A b b b (comp A b a b (inv A a b p) p) (refl A b)) 
lemIdInv A a = J A a (\ b p ->  Id (Id A b b) (refl A b) (comp A b b b (comp A b a b (inv A a b p) p) (refl A b))) rem
  where rem : Id (Id A a a) (refl A a) (refl A a)
        rem = refl (Id A a a) (refl A a)

lemInv : (x:S1) -> Id S1 (mult x (invS1 x)) base
lemInv = hsplit (\ x -> Id S1 (mult x (invS1 x)) base) with
 base -> refl S1 base
 loop -> rem1
   where
    triv : loopS1
    triv = refl S1 base

    F : S1 -> U
    F x = Id S1 (mult x (invS1 x)) base

    rem2 : Id loopS1 triv (compS1 compLoop triv)
    rem2 = lemIdInv S1 base base loop

    rem1 : IdS S1 F base base loop triv triv
    rem1 = substPathPi S1 S1 (\ x -> mult x (invS1 x)) (\x -> base) base base loop triv triv rem2

lemInv1 : (x:S1) -> Id S1 (mult (invS1 x) x) base
lemInv1 x = comp S1 (mult (invS1 x) x) (mult x (invS1 x)) base (multCom (invS1 x) x) (lemInv x)

corrInv : (x y : S1) -> Id S1 (mult x (mult (invS1 x) y)) y
corrInv x y = comp S1 (mult x (mult (invS1 x) y)) (mult (mult x (invS1 x)) y) y rem1 rem
 where rem1 : Id S1 (mult x (mult (invS1 x) y)) (mult (mult x (invS1 x)) y)
       rem1 = multAssoc x (invS1 x) y

       rem : Id S1 (mult (mult x (invS1 x)) y) y
       rem = comp S1 (mult (mult x (invS1 x)) y) (mult base y) y (mapOnPath S1 S1 (\ z -> mult z y) (mult x (invS1 x)) base (lemInv x)) (idL y)

corrInv1 : (x y : S1) -> Id S1 (mult (invS1 x) (mult x y)) y
corrInv1 x y = comp S1 (mult (invS1 x) (mult x y)) (mult (mult (invS1 x) x) y) y rem1 rem
 where rem1 : Id S1 (mult (invS1 x) (mult x y)) (mult (mult (invS1 x) x) y)
       rem1 = multAssoc (invS1 x) x y

       rem : Id S1 (mult (mult (invS1 x) x) y) y
       rem = comp S1 (mult (mult (invS1 x) x) y) (mult base y) y (mapOnPath S1 S1 (\ z -> mult z y) (mult (invS1 x) x) base (lemInv1 x)) (idL y)

-- each x in S1 defines an equality S1 = S1

eqS1 : S1 -> Id U S1 S1
eqS1 x = isoId S1 S1 (mult x) (mult (invS1 x)) (corrInv x) (corrInv1 x)

-- test to compare the two inverses

invSq : S1 -> S1
invSq x = invMult x (invMult x base)

test : Z
test = winding (mapOnPath S1 S1 (\ x -> invSq (invSq (invSq x))) base base loop)

invSq1 : S1 -> S1
invSq1 x = mult (invS1 x) (invS1 x) 

test1 : Z
test1 = winding (mapOnPath S1 S1 (\ x -> invSq1 (invSq1 (invSq1 x))) base base loop)
