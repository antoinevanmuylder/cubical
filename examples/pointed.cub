module pointed where

import lemId
import heterogeneous

-- Pointed types
ptType : U
ptType = (X : U) * X

pt : (Z : ptType) -> Z.1
pt Z = Z.2

-- Maps between pointed types
isPtMap : (A B : ptType) (f : A.1 -> B.1) -> U
isPtMap A B f = Id B.1 (f (pt A)) (pt B)

ptMap : ptType -> ptType -> U
ptMap A B = (f : A.1 -> B.1) * isPtMap A B f

ptMapComp : (A B C : ptType) -> ptMap A B -> ptMap B C -> ptMap A C
ptMapComp A B C f g = (\a -> g.1 (f.1 a), gf0)
  where gf0 : Id C.1 (g.1 (f.1 (pt A))) (pt C)
        gf0 = comp C.1 (g.1 (f.1 (pt A))) (g.1 (pt B)) (pt C)
                (mapOnPath B.1 C.1  g.1 (f.1 (pt A)) (pt B) f.2) g.2

-- The loop space of a pointed type
Omega : ptType -> ptType
Omega Z = (Id Z.1 (pt Z) (pt Z),refl Z.1 (pt Z))

mapOmega : (A B : ptType) (h : ptMap A B) -> ptMap (Omega A) (Omega B)
mapOmega A B h = (omf,omf0)
  where a : A.1
        a = pt A
        b : B.1
        b = pt B
        
        f : A.1 -> B.1
        f = h.1
        f0 : Id B.1 (f a) b
        f0 = h.2

        omf : (Omega A).1 -> (Omega B).1
        omf p = comp (B.1) b (f a) b
                  (comp (B.1) b (f a) (f a)
                    (inv (B.1) (f a) b f0)
                    (mapOnPath (A.1) (B.1) f (pt A) (pt A) p))
                  f0

        omf0 : Id (Omega B).1 (omf (refl A.1 a)) (refl B.1 b)
        omf0 = compInvLeft' B.1 (f a) b f0

-- Iterated loop space
itOmega : N -> ptType -> ptType
itOmega = split
  zero  -> \A -> A
  suc n -> \A -> itOmega n (Omega A)

-- itMapOmega : (n : N) (A B : ptType) (h : ptMap A B) ->
--   ptMap (itOmega n A) (itOmega n B)
-- itMapOmega = split
--   zero  -> \A B h -> h
--   suc n -> \A B h -> mapOmega (itOmega n A) (itOmega n B) (itMapOmega n A B h)

-- Looping a fibration (9.2)

fibOmega : (B : ptType) (P : B.1 -> U) (f : P (pt B)) -> (Omega B).1 -> U
fibOmega B P f p = IdS B.1 P (pt B) (pt B) p f f

-- fibOmegaPt : (B : ptType) (P : B.1 -> U) (f : P (pt B)) -> ptType
-- fibOmegaPt B P f = (fibOmega B P f p,refl (P (pt B)) f)

totalFibOmega : (B : ptType) (P : B.1 -> U) (f : P (pt B)) ->
  (Sigma (Omega B).1 (fibOmega B P f)) -> (Omega (Sigma B.1 P, (pt B, f))).1
totalFibOmega B P f = pairPath B.1 P (pt B) (pt B) f f

itFibOmega : (n : N) (B : ptType) (P : B.1 -> U) (f : P (pt B)) -> (itOmega n B).1 -> U
itFibOmega = split
  zero  -> \B P f -> P
  suc n -> \B P f -> itFibOmega n (Omega B) (fibOmega B P f) (refl (P (pt B)) f)

-- TODO: better name!
isContr : U -> U
isContr A = (a : A) * ((x : A) -> Id A a x)

truncated : U -> N -> U
truncated A = split
  zero  -> isContr A
  suc n -> (x y : A) -> truncated (Id A x y) n

truncFibOmega : (B : ptType) (P : B.1 -> U) (f : P (pt B)) (n : N) ->
  truncated (P (pt B)) (suc n) ->
  (p : (Omega B).1) -> truncated (fibOmega B P f p) n
truncFibOmega B P f n tr p = substInv U (\X -> truncated X n)
  (IdS B.1 P (pt B) (pt B) p f f) (Id (P (pt B)) (subst B.1 P (pt B) (pt B) p f) f)
  (eqSubstSig B.1 P (pt B) (pt B) p f f) (tr (subst B.1 P (pt B) (pt B) p f) f)
