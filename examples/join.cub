module join where

-- import higher
import pointed
import susp
import square

join : U -> U -> U
-- join A B = pushout A B (and A B) (\x -> x.1) (\x -> x.2)
hdata join A B = inl (a:A) | inr (b:B) | push (a:A) (b:B) @ (inl a) ~ (inr b)

mapJoin : (A B C D : U) (f : A -> C) (g : B -> D) -> join A B -> join C D
mapJoin A B C D f g = hsplit (\_ -> join C D) with
  inl a -> inl (f a)
  inr b -> inr (g b)
  push a b -> push (f a) (g b)

inlJoin : (A B C : U) -> join A B -> join A (join B C)
inlJoin A B C = hsplit (\_ -> join A (join B C)) with
  inl a   -> inl a
  inr b   -> inr (inl b)
  push a b -> -- ts: inl a = inr (inl b)
    push a (inl b) 

-- opl2r : (A : U) (a b c : A) (p : Id A a c) (q : Id A a b)
--      (r : Id A b c) ->
--      Square A a b a c (refl A a) r q p ->
--      Square A a c b c q (refl A c) p r
-- opl2r A a b c p q r = op' a b q c p r where

--   op' : (a b : A) (q : Id A a b) (c : A) (p : Id A a c) (r : Id A b c) ->
--          Square A a b a c (refl A a) r q p ->
--          Square A a c b c q (refl A c) p r
--   op' a = J A a (\b q -> (c : A) (p : Id A a c) (r : Id A b c) ->
--                          Square A a b a c (refl A a) r q p ->
--                          Square A a c b c q (refl A c) p r)
--             (\c p r -> op2 a c r p) where

--     op2 : (a c : A) (r p : Id A a c) ->
--             Square A a a a c (refl A a) r (refl A a) p ->
--             Id (Id A a c) p r
--     op2 a = J A a (\c r -> (p : Id A a c) ->
--                            Square A a a a c (refl A a) r (refl A a) p ->
--                            Id (Id A a c) p r)
--               (\p -> inv (Id A a a) (refl A a) p)

-- Version of [opl2r] using transpose. We should use that when [transpose]
-- will be a primitive
opl2r : (A : U) (a b c : A) (p : Id A a c) (q : Id A a b)
     (r : Id A b c) ->
     Square A a b a c (refl A a) r q p ->
     Square A a c b c q (refl A c) p r
opl2r A a b c p q r x = transpose A a c p b c r q (refl A c) (op' a c p b q r x)  where

  op' : (a c : A) (p : Id A a c) (b : A) (q : Id A a b)
       (r : Id A b c) ->
       Square A a b a c (refl A a) r q p ->
       Square A a b c c p r q (refl A c)
  op' a = J A a (\c p ->  (b : A) (q : Id A a b)
                   (r : Id A b c) ->
                   Square A a b a c (refl A a) r q p ->
                   Square A a b c c p r q (refl A c))
            (\b q r x -> x)

l2r : (A B C : U) -> join (join A B) C -> join A (join B C)
l2r A B C = hsplit (\_ -> join A (join B C)) with
  inl jab -> inlJoin A B C jab
  inr c   -> inr (inr c)
  push p q  -> lem q p -- ts: lem p.1 = inr (inr p.2)
    where lem : (c : C) (u : join A B) ->
                Id (join A (join B C)) (inlJoin A B C u) (inr (inr c))
          lem c = hsplit (\u -> Id (join A (join B C))
                          (inlJoin A B C u) (inr (inr c))) with
            inl a -> push a (inr c)
            inr b -> mapOnPath (join B C) (join A (join B C)) inr
                       (inl b) (inr c) (push b c)
            push a b -> substPathPiSquare X Y f g (inl a) (inr b) (push a b) qa qa' rem
             where

              F : join A B -> U
              F u = Id (join A (join B C)) (inlJoin A B C u) (inr (inr c))

              X : U
              X = join A B

              Y : U
              Y = join A (join B C)

              f : X -> Y
              f = inlJoin A B C

              g : X -> Y
              g _ = inr (inr c)

              qa : Id Y (f (inl a)) (g (inl a))
              qa = push a (inr c)

              qa' : Id Y  (f (inr b)) (g (inr b))
              qa' = mapOnPath (join B C) (join A (join B C)) inr
                       (inl b) (inr c) (push b c)

              ap : IdS (join B C) (\x -> Id Y (inl a) (inr x)) (inl b) (inr c)
                       (push b c) (push a (inl b)) (push a (inr c))
              ap = mapOnPathD (join B C) (\x -> Id Y (inl a) (inr x))
                    (\x -> push a x)
                    (inl b) (inr c) (push b c)

              rem2 : Square Y (inl a) (inr (inl b)) (inl a) (inr (inr c))
                        (refl Y (inl a))
                        qa'
                        (push a (inl b))
                        qa
              rem2 = substPathPiInvSquare (join B C) Y (\_ -> inl a) inr (inl b) (inr c)
                       (push b c) (push a (inl b)) (push a (inr c)) ap

              rem : Square Y (inl a) (inr (inr c)) (inr (inl b)) (inr (inr c))
                       (push a (inl b))
                       (refl Y (inr (inr c)))
                       qa
                       qa'
              rem = opl2r Y (inl a) (inr (inl b)) (inr (inr c))
                       qa (push a (inl b)) qa'
                       rem2

inrJoin : (A B C : U) -> join B C -> join (join A B) C
inrJoin A B C = hsplit (\_ -> join (join A B) C) with
  inl b   -> inl (inr b)
  inr c   -> inr c
  push b c -> push (inr b) c

-- -- TODO: have a smaller proof term
-- opr2l : (A : U) (a b c : A) (p : Id A a c) (q : Id A a b)
--      (r : Id A b c) ->
--      Square A a c b c q (refl A c) p r ->
--      Square A a b a c (refl A a) r q p
-- opr2l A a b c p q r = op' a b q c p r where

--   op' : (a b : A) (q : Id A a b) (c : A) (p : Id A a c) (r : Id A b c) ->
--          Square A a c b c q (refl A c) p r ->
--          Square A a b a c (refl A a) r q p
--   op' a = J A a (\b q -> (c : A) (p : Id A a c) (r : Id A b c) ->
--                          Square A a c b c q (refl A c) p r ->
--                          Square A a b a c (refl A a) r q p)
--             (\c p r -> op2 a c r p) where

--     op2 : (a c : A) (r p : Id A a c) ->
--             Id (Id A a c) p r ->
--             Square A a a a c (refl A a) r (refl A a) p
--     op2 a = J A a (\c r -> (p : Id A a c) ->
--                            Id (Id A a c) p r ->
--                            Square A a a a c (refl A a) r (refl A a) p)
--               (\p -> inv (Id A a a) p (refl A a))

-- Version of [opl2r] using transpose. We should use that when [transpose]
-- will be a primitive
opr2l : (A : U) (a b c : A) (p : Id A a c) (q : Id A a b)
     (r : Id A b c) ->
     Square A a c b c q (refl A c) p r ->
     Square A a b a c (refl A a) r q p
opr2l A a b c p q r x = transpose A a b q a c p (refl A a) r (op' a c p b q r x)  where

  op' : (a c : A) (p : Id A a c) (b : A) (q : Id A a b)
       (r : Id A b c) ->
       Square A a c b c q (refl A c) p r ->
       Square A a a b c q p (refl A a) r
  op' a = J A a (\c p ->  (b : A) (q : Id A a b)
                   (r : Id A b c) ->
                   Square A a c b c q (refl A c) p r ->
                   Square A a a b c q p (refl A a) r)
            (\b q r x -> x)

r2l : (A B C : U) -> join A (join B C) -> join (join A B) C
r2l A B C = hsplit (\_ -> join (join A B) C) with
  inl a  -> inl (inl a)
  inr bc -> inrJoin A B C bc
  push a bc -> lem a bc
    where
      lem : (a : A) (u : join B C) ->
            Id (join (join A B) C) (inl (inl a)) (inrJoin A B C u)
      lem a =
         hsplit (\u -> Id (join (join A B) C)
                          (inl (inl a)) (inrJoin A B C u)) with
           inl b -> mapOnPath (join A B) (join (join A B) C)
                      inl (inl a) (inr b) (push a b)
           inr c -> push (inl a) c
           push b c -> substPathPiSquare jBC jjABC (\_ -> inl (inl a)) (inrJoin A B C)
                        (inl b) (inr c) (push b c)
                        (mapOnPath (join A B) (join (join A B) C)
                             inl (inl a) (inr b) (push a b))
                        (push (inl a) c)
                        (opr2l jjABC (inl (inl a)) (inl (inr b)) (inr c)
                          (push (inl a) c)
                          (mapOnPath (join A B) (join (join A B) C)
                              inl (inl a) (inr b) (push a b))
                          (push (inr b) c)
                          out)
           -- ts: IdS (join B C) G (inl b) (inr c) (push b c)
           --         (mapOnPath (join A B) (join (join A B) C)
           --                 inl (inl a) (inr b) (push a b))
           --         (push (inl a) c)
             where
               jAB : U
               jAB = join A B

               jBC : U
               jBC = join B C

               G : jBC -> U
               G u = Id (join (join A B) C)
                        (inl (inl a)) (inrJoin A B C u)
               jjABC : U
               jjABC = join (join A B) C

               F : jAB -> U
               F w = Id jjABC (inl w) (inr c)

               appush2 : IdS jAB F (inl a) (inr b) (push a b)
                             (push (inl a) c) (push (inr b) c)
               appush2 = mapOnPathD jAB F
                 (\w -> push w c) (inl a) (inr b) (push a b)

               out : Square jjABC (inl (inl a)) (inr c) (inl (inr b)) (inr c)
                        (mapOnPath jAB jjABC inl (inl a) (inr b) (push a b))
                        (refl jjABC (inr c))
                        (push (inl a) c)
                        (push (inr b) c)
               out = substPathPiInvSquare jAB jjABC inl (\_ -> inr c)
                       (inl a) (inr b) (push a b)
                       (push (inl a) c) (push (inr b) c) appush2


--  Suspension and join with the booleans
suspJoin : (A : U) -> susp A -> join Bool A
suspJoin A = hsplit (\_ -> join Bool A) with
  north   -> inl true
  south   -> inl false
  merid a -> comp (join Bool A) (inl true) (inr a) (inl false)
              (push true a)
              (inv (join Bool A) (inl false) (inr a) (push false a))

suspJoinInv : (A : U) -> join Bool A -> susp A
suspJoinInv A = hsplit (\_ -> susp A) with
  inl b -> cases b
    where cases : Bool -> susp A
          cases = split
            true  -> north
            false -> south
  inr a -> south
  push b a -> cases a b
    where cases : (a : A) (b : Bool) ->
                    Id (susp A) (suspJoinInv A (inl b)) south
          cases a = split
            true  -> merid a
            false -> refl (susp A) south

ptJoin : ptType -> U -> ptType
ptJoin pA B = (join pA.1 B, inl (pt pA))

ptBool : ptType
ptBool = (Bool,true)

--

bjbToS1 : join Bool Bool -> S1
bjbToS1 x = s1ToCircle (suspJoinInv Bool x)

bjbToS1Inv : S1 -> join Bool Bool
bjbToS1Inv x = suspJoin Bool (circleToS1 x)


one : N
one = suc zero

two : N
two = suc one

three : N
three = suc (two)

S2 : U
S2 = plusOneSphere one

ptS2 : ptType
ptS2 = ptPlusOneSphere one

S3 : U
S3 = plusOneSphere two

ptS3 : ptType
ptS3 = ptPlusOneSphere two




-- The map e^-1 from 7.3
s3ToS1JoinS1Inv : join S1 S1 -> S3
s3ToS1JoinS1Inv x =
  suspJoinInv S2
    (mapJoin Bool (join Bool S1) Bool S2 (\b -> b) (suspJoinInv S1)
      (l2r Bool Bool S1
        (mapJoin S1 S1 (join Bool Bool) S1 bjbToS1Inv (\z -> z) x)))

-- The map e from 7.3
s3ToS1JoinS1 : S3 -> join S1 S1
s3ToS1JoinS1 x =
  mapJoin (join Bool Bool) S1 S1 S1 bjbToS1 (\z -> z)
          (r2l Bool Bool S1
            (mapJoin Bool S2 Bool (join Bool S1) (\b -> b) (suspJoin S1)
              (suspJoin S2 x)))

-- -- The main map alpha from 8
-- alpha : join S1 S1 -> S2
-- alpha = hsplit (\_ -> S2) with
--   inl x   -> south
--   inr y   -> south
--   push x y -> comp S2 south north south
--               (inv S2 north south (merid y))
--               (merid x)

-- A modified version of the main map alpha from 8, which is equal to the
-- other one (to be checked) but pointed by reflexivity
alpha : join S1 S1 -> S2
alpha = hsplit (\_ -> S2) with
  inl x   -> north
  inr y   -> north
  push x y -> idEuclid S2 north north south (merid x) (merid y)

ptAlpha : ptMap (ptJoin ptS1 S1) ptS2
ptAlpha = (alpha, refl S2 north)
