module join where

import higher
import pointed
import susp

join : U -> U -> U
join A B = pushout A B (and A B) (\x -> x.1) (\x -> x.2)


mapJoin : (A B C D : U) (f : A -> C) (g : B -> D) -> join A B -> join C D
mapJoin A B C D f g = hsplit (\_ -> join C D) with
  inl a -> inl (f a)
  inr b -> inr (g b)
  push ab -> push (f ab.1, g ab.2)

inlJoin : (A B C : U) -> join A B -> join A (join B C)
inlJoin A B C = hsplit (\_ -> join A (join B C)) with
  inl a   -> inl a
  inr b   -> inr (inl b)
  push ab -> -- ts: inl ab.1 = inr (inl ab.2)
    push (ab.1, inl ab.2)


l2r : (A B C : U) -> join (join A B) C -> join A (join B C)
l2r A B C = hsplit (\_ -> join A (join B C)) with
  inl jab -> inlJoin A B C jab
  inr c   -> inr (inr c)
  push p  -> lem p.2 p.1 -- ts: lem p.1 = inr (inr p.2)
    where lem : (c : C) (u : join A B) ->
                Id (join A (join B C)) (inlJoin A B C u) (inr (inr c))
          lem c = hsplit (\u -> Id (join A (join B C))
                          (inlJoin A B C u) (inr (inr c))) with
            inl a -> push (a, inr c)
            inr b -> mapOnPath (join B C) (join A (join B C)) inr
                       (inl b) (inr c) (push (b,c))
            push ab -> let

              F : join A B -> U
              F u = Id (join A (join B C)) (inlJoin A B C u) (inr (inr c))
              a : A
              a = ab.1

              b : B
              b = ab.2
              X : U
              X = join A B

              Y : U
              Y = join A (join B C)

              f : X -> Y
              f = inlJoin A B C

              g : X -> Y
              g _ = inr (inr c)

              qa : Id Y (f (inl a)) (g (inl a))
              qa = push (a,inr c)

              qa' : Id Y  (f (inr b)) (g (inr b))
              qa' = mapOnPath (join B C) (join A (join B C)) inr
                       (inl b) (inr c) (push (b,c))

              ap : IdS (join B C) (\x -> Id Y (inl a) (inr x)) (inl b) (inr c)
                       (push (b,c)) (push (a,inl b)) (push (a,inr c))
              ap = mapOnPathD (join B C) (\x -> Id Y (inl a) (inr x))
                    (\x -> push (a, x))
                    (inl b) (inr c) (push (b,c))

              rem2 : Id (Id Y (inl a) (inr (inr c)))
                        (comp Y (inl a) (inr (inl b)) (inr (inr c))
                          (push (a,inl b)) qa')
                        (comp Y (inl a) (inl a) (inr (inr c)) (refl Y (inl a)) qa)
              rem2 = substPathPiInv (join B C) Y (\_ -> inl a) inr (inl b) (inr c)
                       (push (b,c)) (push (a,inl b)) (push (a,inr c)) ap

              rem : Id (Id Y (inl a) (inr (inr c))) qa
                       (comp Y (inl a) (inr (inl b)) (inr (inr c))
                         (push (a, inl b)) qa')
              rem = comp (Id Y (inl a) (inr (inr c)))
                      qa
                      (comp Y (inl a) (inl a) (inr (inr c)) (refl Y (inl a)) qa)
                      (comp Y (inl a) (inr (inl b)) (inr (inr c))
                         (push (a, inl b)) qa')
                      (compInvIdl Y (f (inl a)) (g (inl a)) qa)
                      (inv (Id Y (inl a) (inr (inr c)))
                        (comp Y (inl a) (inr (inl b)) (inr (inr c))
                          (push (a,inl b)) qa')
                        (comp Y (inl a) (inl a) (inr (inr c)) (refl Y (inl a)) qa)
                      rem2)

              in substPathPi X Y f g (inl a) (inr b) (push ab) qa qa' rem

inrJoin : (A B C : U) -> join B C -> join (join A B) C
inrJoin A B C = hsplit (\_ -> join (join A B) C) with
  inl b   -> inl (inr b)
  inr c   -> inr c
  push bc -> push (inr bc.1, bc.2)

r2l : (A B C : U) -> join A (join B C) -> join (join A B) C
r2l A B C = hsplit (\_ -> join (join A B) C) with
  inl a  -> inl (inl a)
  inr bc -> inrJoin A B C bc
  push abc -> lem abc.1 abc.2
    where
      lem : (a : A) (u : join B C) ->
            Id (join (join A B) C) (inl (inl a)) (inrJoin A B C u)
      lem a =
         hsplit (\u -> Id (join (join A B) C)
                          (inl (inl a)) (inrJoin A B C u)) with
           inl b -> mapOnPath (join A B) (join (join A B) C)
                      inl (inl a) (inr b) (push (a,b))
           inr c -> push (inl a,c)
           push bc -> substPathPi jBC jjABC (\_ -> inl (inl a)) (inrJoin A B C)
                        (inl b) (inr c) (push (b,c))
                        (mapOnPath (join A B) (join (join A B) C)
                             inl (inl a) (inr b) (push (a,b)))
                        (push (inl a,c))
                        (op jjABC (inl (inl a)) (inl (inr b)) (inr c)
                          (push (inl a,c))
                          (mapOnPath (join A B) (join (join A B) C)
                              inl (inl a) (inr b) (push (a,b)))
                          (push (inr b,c))
                          out)
           -- ts: IdS (join B C) G (inl b) (inr c) (push (b,c))
           --         (mapOnPath (join A B) (join (join A B) C)
           --                 inl (inl a) (inr b) (push (a,b)))
           --         (push (inl a,c))
             where
               jAB : U
               jAB = join A B

               jBC : U
               jBC = join B C

               G : jBC -> U
               G u = Id (join (join A B) C)
                        (inl (inl a)) (inrJoin A B C u)
               jjABC : U
               jjABC = join (join A B) C
               b : B
               b = bc.1
               c : C
               c = bc.2

               F : jAB -> U
               F w = Id jjABC (inl w) (inr c)

               appush2 : IdS jAB F (inl a) (inr b) (push (a,b))
                             (push (inl a,c)) (push (inr b,c))
               appush2 = mapOnPathD jAB F
                 (\w -> push (w,c)) (inl a) (inr b) (push (a,b))

               out : Id (Id jjABC (inl (inl a)) (inr c))
                        (push (inl a,c))
                        (comp jjABC (inl (inl a)) (inl (inr b)) (inr c)
                          (mapOnPath jAB jjABC inl (inl a) (inr b) (push (a,b)))
                          (push (inr b,c)))
               out = substPathPiInv jAB jjABC inl (\_ -> inr c)
                       (inl a) (inr b) (push (a,b))
                       (push (inl a,c)) (push (inr b,c)) appush2

               op : (A : U) (a b c : A) (p : Id A a c) (q : Id A a b)
                    (r : Id A b c) ->
                    Id (Id A a c) p (comp A a b c q r) ->
                    Id (Id A a c) (comp A a b c q r) (comp A a a c (refl A a) p)
               op A a b = J A a (\c p ->  (q : Id A a b) (r : Id A b c) ->
                    Id (Id A a c) p (comp A a b c q r) ->
                    Id (Id A a c) (comp A a b c q r) (comp A a a c (refl A a) p))
                    (\q r -> inv (Id A a a) (refl A a) (comp A a b a q r))


--  Suspension and join with the booleans
suspJoin : (A : U) -> susp A -> join Bool A
suspJoin A = hsplit (\_ -> join Bool A) with
  north   -> inl true
  south   -> inl false
  merid a -> comp (join Bool A) (inl true) (inr a) (inl false)
              (push (true,a))
              (inv (join Bool A) (inl false) (inr a) (push (false,a)))

suspJoinInv : (A : U) -> join Bool A -> susp A
suspJoinInv A = hsplit (\_ -> susp A) with
  inl b -> cases b
    where cases : Bool -> susp A
          cases = split
            true  -> north
            false -> south
  inr a -> south
  push ba -> cases ba.2 ba.1
    where cases : (a : A) (b : Bool) ->
                    Id (susp A) (suspJoinInv A (inl b)) south
          cases a = split
            true  -> merid a
            false -> refl (susp A) south

ptJoin : ptType -> U -> ptType
ptJoin pA B = (join pA.1 B, inl (pt pA))

ptBool : ptType
ptBool = (Bool,true)

--

bjbToS1 : join Bool Bool -> S1
bjbToS1 x = s1ToCircle (suspJoinInv Bool x)

bjbToS1Inv : S1 -> join Bool Bool
bjbToS1Inv x = suspJoin Bool (circleToS1 x)


one : N
one = suc zero

two : N
two = suc one

three : N
three = suc (two)

S2 : U
S2 = plusOneSphere one

ptS2 : ptType
ptS2 = ptPlusOneSphere one

S3 : U
S3 = plusOneSphere two

ptS3 : ptType
ptS3 = ptPlusOneSphere two




-- The map e^-1 from 7.3
s3ToS1JoinS1Inv : join S1 S1 -> S3
s3ToS1JoinS1Inv x =
  suspJoinInv S2
    (mapJoin Bool (join Bool S1) Bool S2 (\b -> b) (suspJoinInv S1)
      (l2r Bool Bool S1
        (mapJoin S1 S1 (join Bool Bool) S1 bjbToS1Inv (\z -> z) x)))


-- The map e from 7.3
s3ToS1JoinS1 : S3 -> join S1 S1
s3ToS1JoinS1 x =
  mapJoin (join Bool Bool) S1 S1 S1 bjbToS1 (\z -> z)
    (r2l Bool Bool S1
      (mapJoin Bool S2 Bool (join Bool S1) (\b -> b) (suspJoin S1)
        (suspJoin S2 x)))

-- -- The main map alpha from 8
-- alpha : join S1 S1 -> S2
-- alpha = hsplit (\_ -> S2) with
--   inl x   -> south
--   inr y   -> south
--   push xy -> comp S2 south north south
--               (inv S2 north south (merid xy.2))
--               (merid xy.1)
--
-- ptAlpha : ptMap (ptJoin ptS1 S1) ptS2
-- ptAlpha = (alpha, inv S2 north south (merid base))


-- A modified version of the main map alpha from 8, which is equal to the
-- other one but pointed by reflexivity

alpha : join S1 S1 -> S2
alpha = hsplit (\_ -> S2) with
  inl x   -> north
  inr y   -> north
  push xy -> comp S2 north north north
               (idEuclid S2 north north south (merid base) (merid xy.2))
               (idEuclid S2 north north south (merid xy.1) (merid base))
