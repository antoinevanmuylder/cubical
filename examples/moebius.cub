module moebius where

import prelude
import circle
import square
import mult


invMult : S1 -> S1 -> S1
invMult x y = rem1.1
 where
  rem : isContr (fiber S1 S1 (mult x) y)
  rem = multIsEquiv x y

  rem1 : fiber S1 S1 (mult x) y
  rem1 = rem.2

-- The other version of the circle.
S1' : U
hdata S1' = base1 | base2 | loop1 @ base1 ~ base2 | loop2 @ base2 ~ base1

-- The double covering space

neg : Bool -> Bool
neg = split
  true -> false
  false -> true

negNeg : (b : Bool) -> Id Bool (neg (neg b)) b
negNeg = split
  true -> refl Bool true
  false -> refl Bool false

doubleCov : S1 -> U
doubleCov = hsplit (\_ -> U) with
  base -> Bool
  loop -> isoId Bool Bool neg neg negNeg negNeg

M : U
M = Sigma S1 doubleCov

base1M : M
base1M = (base, true)

base2M : M
base2M = (base, false)

loop1M : Id M base1M base2M
loop1M = pairPathSubst S1 doubleCov base base loop true

loop2M : Id M base2M base1M
loop2M = pairPathSubst S1 doubleCov base base loop false

loopM : Id M base1M base1M
loopM = comp M base1M base2M base1M loop1M loop2M

-- The map from M to S1'

BoolToS1' : Bool -> S1'
BoolToS1' = split
  true -> base1
  false -> base2

haux : (b : Bool) -> Id S1' (BoolToS1' b) (BoolToS1' (subst S1 doubleCov base base loop b))
haux = split
  true  -> loop1
  false -> loop2

aux : (x : S1) -> doubleCov x -> S1'
aux = hsplit (\x -> (doubleCov x -> S1')) with
  base -> BoolToS1'
  loop -> funExt1 S1 S1' doubleCov base base loop BoolToS1' BoolToS1' haux

mapFromDoubleCov : M -> S1'
mapFromDoubleCov xy = aux xy.1 xy.2

-- The map from S1' to M

mapToDoubleCov : S1' -> M
mapToDoubleCov = hsplit (\_ -> M) with
  base1 -> base1M
  base2 -> base2M
  loop1 -> loop1M
  loop2 -> loop2M

-- First composition

S1toS1Inv : (x : S1') -> Id S1' (mapFromDoubleCov (mapToDoubleCov x)) x
S1toS1Inv = hsplit (\ x -> Id S1' (mapFromDoubleCov (mapToDoubleCov x)) x) with
  base1 -> refl S1' base1
  base2 -> refl S1' base2
  loop1 -> substPathPiSquareTranspose S1' S1' (\x -> mapFromDoubleCov (mapToDoubleCov x)) (\x -> x) base1 base2 loop1 (refl S1' base1) (refl S1' base2)
                                      (refl (Id S1' base1 base2) loop1)
  loop2 -> substPathPiSquareTranspose S1' S1' (\x -> mapFromDoubleCov (mapToDoubleCov x)) (\x -> x) base2 base1 loop2 (refl S1' base2) (refl S1' base1)
                                      (refl (Id S1' base2 base1) loop2)

hdegenSquareInv : (A : U) (a b : A) (p p' : Id A a b) -> Square A a b p a b p' (refl A a) (refl A b) -> Id (Id A a b) p p'
hdegenSquareInv A a b p p' s = transpose A a b p a b p' (refl A a) (refl A b) s

lemma : (A B : U) (f g : A -> B) (a a' : A) (p : Id A a a') (q : Id B (f a) (g a)) (q' : Id B (f a') (g a'))
  -> Square B (f a) (g a) q (f a') (g a') q' (mapOnPath A B f a a' p) (mapOnPath A B g a a' p)
  -> Id (Id B (f a') (g a')) (subst A (\x -> Id B (f x) (g x)) a a' p q) q'
lemma A B f g a = J A a (\a' p -> (q : Id B (f a) (g a)) (q' : Id B (f a') (g a'))
                              -> Square B (f a) (g a) q (f a') (g a') q' (mapOnPath A B f a a' p) (mapOnPath A B g a a' p)
                              -> Id (Id B (f a') (g a')) (subst A (\x -> Id B (f x) (g x)) a a' p q) q')
                   (hdegenSquareInv B (f a) (g a))


rem : (b : Bool) -> Id M (mapToDoubleCov (BoolToS1' b)) (base, b)
rem = split
  true -> refl M base1M
  false -> refl M base2M

MtoMInvaux : (x : S1) (y : doubleCov x) -> Id M (mapToDoubleCov (aux x y)) (x, y)
MtoMInvaux = hsplit (\ x -> (y : doubleCov x) -> Id M (mapToDoubleCov (aux x y)) (x, y)) with
  base -> rem
  loop -> funExtFull S1 doubleCov (\ x y -> Id M (mapToDoubleCov (aux x y)) (x, y)) base base loop rem rem rem2  where

    rem2 : (b : Bool) -> Id (Id M (mapToDoubleCov (BoolToS1' (neg b))) (base, neg b))
                            (subst M (\xy -> Id M (mapToDoubleCov (aux xy.1 xy.2)) xy) (base, b) (base, neg b)
                                   (pairPathSubst S1 doubleCov base base loop b) (rem b))
                            (rem (neg b))
    rem2 = split
      true  -> rem3 where

        rem3 : Id (Id M base2M base2M)
                            (subst M (\xy -> Id M (mapToDoubleCov (aux xy.1 xy.2)) xy) base1M base2M
                                   loop1M (refl M base1M))
                            (refl M base2M)
        rem3 = lemma M M (\xy -> mapToDoubleCov (aux xy.1 xy.2)) (\xy -> xy) base1M base2M loop1M (refl M base1M) (refl M base2M) (refl (Id M base1M base2M) loop1M)

      false -> rem3 where

        rem3 : Id (Id M base1M base1M)
                            (subst M (\xy -> Id M (mapToDoubleCov (aux xy.1 xy.2)) xy) base2M base1M
                                   loop2M (refl M base2M))
                            (refl M base1M)
        rem3 = lemma M M (\xy -> mapToDoubleCov (aux xy.1 xy.2)) (\xy -> xy) base2M base1M loop2M (refl M base2M) (refl M base1M) (refl (Id M base2M base1M) loop2M)

MtoMInv : (xy : M) -> Id M (mapToDoubleCov (mapFromDoubleCov xy)) xy
MtoMInv xy = MtoMInvaux xy.1 xy.2

theorem : Id U S1' M 
theorem = isoId S1' M mapToDoubleCov mapFromDoubleCov MtoMInv S1toS1Inv

---

to : S1 -> S1'
to = hsplit (\_ -> S1') with
  base -> base1
  loop -> comp S1' base1 base2 base1 loop1 loop2

from : S1' -> S1
from = hsplit (\_ -> S1) with
  base1 -> base
  base2 -> base
  loop1 -> loop
  loop2 -> refl S1 base

fromTo : (x : S1) -> Id S1 (from (to x)) x
fromTo = hsplit (\x -> Id S1 (from (to x)) x) with
  base -> refl S1 base
  loop -> substPathPiSquareTranspose S1 S1 (\x -> from (to x)) (\x -> x) base base loop (refl S1 base) (refl S1 base) (refl (Id S1 base base) loop)

toFrom : (x : S1') -> Id S1' (to (from x)) x
toFrom = hsplit (\x -> Id S1' (to (from x)) x) with
  base1 -> refl S1' base1
  base2 -> inv S1' base2 base1 loop2
  loop1 -> substPathPi S1' S1' (\x -> to (from x)) (\x -> x) base1 base2 loop1 (refl S1' base1) (inv S1' base2 base1 loop2) (lemma S1' base1 base2 loop1 base1 loop2)
         where

    lemma : (A : U) (a b : A) (p : Id A a b) (c : A) (q : Id A b c) -> Id (Id A a b) (comp A a a b (refl A a) p) (comp A a c b (comp A a b c p q) (inv A b c q))
    lemma A a = J A a (\b p -> (c : A) (q : Id A b c) -> Id (Id A a b) (comp A a a b (refl A a) p) (comp A a c b (comp A a b c p q) (inv A b c q)))
                (J A a (\c q -> Id (Id A a a) (refl A a) (comp A a c a (comp A a a c (refl A a) q) (inv A a c q)))
                 (refl (Id A a a) (refl A a)))

  loop2 -> substPathPi S1' S1' (\x -> to (from x)) (\x -> x) base2 base1 loop2 (inv S1' base2 base1 loop2) (refl S1' base1) (compInvLeft' S1' base2 base1 loop2)

theorem2 : Id U S1 S1'
theorem2 = isoId S1 S1' to from toFrom fromTo

theorem3 : Id U S1 M
theorem3 = comp U S1 S1' M theorem2 theorem

---

winding : loopS1 -> Z
winding = encode base

winding' : Id M base1M base1M -> Z
winding' l = winding (mapOnPath M S1 (transpInv S1 M theorem3) base1M base1M l)

multS : M -> M -> M
multS = subst U (\ X -> X -> X -> X) S1 M theorem3 mult

multUncurryS : and M M -> M
multUncurryS = subst U (\ X -> and X X -> X) S1 M theorem3 (\xy -> mult xy.1 xy.2)

multUnitS : M -> M
multUnitS = subst U (\ X -> X -> X) S1 M theorem3 (mult base)

mult' : M -> M -> M
mult' a b = mapToDoubleCov (to (mult (from (mapFromDoubleCov a)) (from (mapFromDoubleCov b))))

equal : (a b : M) -> Id M (multS a b) (mult' a b)
equal a b = refl M (mult' a b)

invMultS : M -> M -> M
invMultS = subst U (\ X -> X -> X -> X) S1 M theorem3 invMult

invSqS : M -> M
invSqS x = invMultS x (invMultS x base1M)

invSqS' : M -> M
invSqS' = subst U (\X -> X -> X) S1 M theorem3 (\x -> invMult x (invMult x base))

SqS : M -> M
SqS x = multS x (multS x base1M)

test1S : Z
test1S = winding' (mapOnPath M M invSqS base1M base1M loopM)

test1S' : Z
test1S' = winding' (mapOnPath M M invSqS' base1M base1M loopM)

test2S : Z
test2S = winding' (mapOnPath M M SqS base1M base1M loopM)

test3S : Z
test3S = winding' loopM

test4S : Z
test4S = winding' (mapOnPath M M (\x -> multS x base1M) base1M base1M loopM)

test4SUnit : Z
test4SUnit = winding' (mapOnPath M M multUnitS base1M base1M loopM)

test4SUncurry : Z
test4SUncurry = winding' (mapOnPath M M (\x -> multUncurryS (x, base1M)) base1M base1M loopM)

test4Sabs : (p : Id M base1M base1M) -> Z
test4Sabs p = winding' (mapOnPath M M (\x -> multS x base1M) base1M base1M p)

test4Sabs' : (p : Id M base1M base1M) -> Z
test4Sabs' p = winding' (mapOnPath M M (\x -> mult' x base1M) base1M base1M p)

test4SabsEq : (p : Id M base1M base1M) -> Id Z (test4Sabs p) (test4Sabs' p)
test4SabsEq p = refl Z (test4Sabs' p)

test4Smult' : Z
test4Smult' = winding' (mapOnPath M M (\x -> mult' x base1M) base1M base1M loopM)

-- test4SEq : Id Z test4S (posZ zero)
-- test4SEq = refl Z test4Smult'

test4S' : Z
test4S' = winding' (mapOnPath M M (multS base1M) base1M base1M loopM)

test5S : Z
test5S = winding' (mapOnPath M M (\x -> multS base1M (multS base1M x)) base1M base1M loopM)

test6S : Z
test6S = winding' (mapOnPath M M (\x -> multS x x) base1M base1M loopM)

test6Smult' : Z
test6Smult' = winding' (mapOnPath M M (\x -> mult' x x) base1M base1M loopM)

-- invS : M -> M
-- invS = subst U (\ X -> X -> X) S1 M theorem3 invS1

-- test7Smult' : Z
-- test7Smult' = winding' (mapOnPath M M (\x -> mult' (mult' x (invS x)) (mult' (invS x) (invS x))) base1M base1M loopM)

-- testInvS : Z
-- testInvS = winding' (mapOnPath M M invS base1M base1M loopM)

-- testInv2S : Z
-- testInv2S = winding' (mapOnPath M M (\x -> invS (invS x)) base1M base1M loopM)

-- -- rem1 : (A B : U) (p : Id U A B) (a:A) -> Id U (Id A a a) (Id B (transport A B p a) (transport A B p a))
-- -- rem1 A = J U A (\ B p -> (a:A) -> Id U (Id A a a) (Id B (transport A B p a) (transport A B p a))) (\ a -> refl U (Id A a a))

-- -- rem1IdP : (A B : U) (p : Id U A B) (a:A) (q : Id A a a) ->
-- --      IdP (Id A a a) (Id B (transport A B p a) (transport A B p a)) (rem1 A B p a) q (mapOnPath A B (transport A B p) a a q)
-- -- rem1IdP A =
-- --   J U A (\ B p -> (a:A) (q : Id A a a) ->
-- --      IdP (Id A a a) (Id B (transport A B p a) (transport A B p a)) (rem1 A B p a) q (mapOnPath A B (transport A B p) a a q))
-- --      (\ a q -> refl (Id A a a) q)

-- invTm : Id U M S1'
-- invTm = inv U S1' M theorem

-- theoremInv : Id U M S1' 
-- theoremInv = isoId M S1' mapFromDoubleCov mapToDoubleCov S1toS1Inv MtoMInv

-- -- test3M : IdP (Id M base1M base1M) (Id S1' base1 base1) (rem1 M S1' invTm base1M) loopM (mapOnPath M S1' (transport M S1' invTm) base1M base1M loopM)
-- -- test3M = rem1IdP M S1' invTm base1M loopM
