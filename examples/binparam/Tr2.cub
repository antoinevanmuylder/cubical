module Tr2 where

mutual
  V : forall i. U
  data V <i> = `U
             | `Pi (A : V@i) (B : El@i A -> V@i)
             | `K (A : forall j. U)
                  (f : A@0 -> A@1)
                  (g : (x:A@0) -> (A ? x & (f x)))


  El :  forall i. V@i -> U
  El = <i> split
                      `U -> U
                      `Pi A B -> (x : El@i A) -> El@i (B x)
                      `K A _ _ -> A@0@i

                       -- @0 because the color dependency was made
                       -- explicit in the data definition; we want to
                       -- ignore the implicit color i in there.


lifting : forall i. (T : V@i) -> El@0 T/i@0 -> El@i T
lifting = <i> split
   `U -> \A -> A
   `Pi A B -> \f a -> let A' : forall j. V@j
                          A' = A/i
                          a' : forall j. El@j A'@j
                          a' = a/i
                      in lifting@i (B a) (f a'@0)
   `K A f -> \x -> [x, f x]@i


-- lift : (T : forall i. V@i) (z : El@0 T@0) -> forall i. El@i T@i
-- lift T z = <i> lifting@i T@i z



-- List : U -> U
-- data List A = Nil | Cons (x : A) (xs : List A)

-- append : (A : U) -> List A -> List A -> List A
-- append A xs = split
--   Nil -> xs
--   Cons y ys -> Cons y (append A xs ys)

-- Tree : U -> U
-- data Tree A = Leaf | Bin (l:Tree A) (x:A) (r : Tree A)

-- flatten : (A : U) -> Tree A -> List A
-- flatten A = split
--   Leaf -> Nil
--   Bin l x r -> append A (Cons x (flatten A r)) (flatten A l)

-- embed : (A : U) -> List A -> Tree A
-- embed A = split
--   Nil -> Leaf
--   Cons x xs -> Bin Leaf x (embed A xs)

-- True : U
-- data True = tt

-- False : U
-- data False =

-- EqList : (A : U) -> List A -> List A -> U
-- EqList A = split
--   Nil -> split
--     Nil -> True
--     Cons _ _ -> False
--   Cons x xs -> split
--     Nil -> False
--     Cons y ys -> -- TODO x == y
--                  EqList A xs ys


-- Related :  (A : U) -> List A -> Tree A -> U
-- Related A xs t = EqList A xs (flatten A t)


-- LIST : forall i. (A : U) -> U
-- LIST A = [List A, Psi (List A) P]
--    where P : List A -> U
--          P x = (t : Tree A) * Related A x t

-- rev' : LIST A