module singlecovering where

import prelude
import circle
import square
import mult2

idUnit : Unit -> Unit
idUnit = split tt -> tt

idUnitInvol : (x : Unit) -> Id Unit (idUnit (idUnit x)) x
idUnitInvol = split tt -> refl Unit tt

eqUnit : Id U Unit Unit
eqUnit = isoId Unit Unit idUnit idUnit idUnitInvol idUnitInvol

singleCov : S1 -> U
singleCov = hsplit (\_ -> U) with
  base -> Unit
  loop -> eqUnit

MS : U
MS = Sigma S1 singleCov

baseS : MS
baseS = (base, tt)

loopS : Id MS baseS baseS
loopS = pairPathSubst S1 singleCov base base loop tt

toS : S1 -> MS
toS = hsplit (\_ -> MS) with
  base -> baseS
  loop -> loopS

fromScurBase : (y : Unit) -> S1
fromScurBase = split tt -> base

fromScurLoop : (y : Unit) -> Id S1 (fromScurBase y) (fromScurBase (subst S1 singleCov base base loop y))
fromScurLoop = split tt -> loop

fromScur : (x : S1) (y : singleCov x) -> S1
fromScur = hsplit (\x -> (y : singleCov x) -> S1) with
  base -> fromScurBase
  loop -> funExt1 S1 S1 singleCov base base loop fromScurBase fromScurBase fromScurLoop

fromS : MS -> S1
fromS xy = fromScur xy.1 xy.2

fromToS : (x : S1) -> Id S1 (fromS (toS x)) x
fromToS = hsplit (\x -> Id S1 (fromS (toS x)) x) with
  base -> refl S1 base
  loop -> substPathPiSquareTranspose S1 S1 (\x -> fromS (toS x)) (\x -> x) base base loop (refl S1 base) (refl S1 base) (compIdl S1 base base loop)

toFromScurBase : (y : Unit) -> Id MS (toS (fromScurBase y)) (base, y)
toFromScurBase = split tt -> refl MS (base, tt)

toFromScurLoop : (y : Unit) -> Id (Id MS (toS (fromScurBase (idUnit y))) (base, idUnit y))
                            (subst MS (\xy -> Id MS (toS (fromScur xy.1 xy.2)) xy) (base, y) (base, idUnit y)
                                   (pairPathSubst S1 singleCov base base loop y) (toFromScurBase y))
                            (toFromScurBase (idUnit y))
toFromScurLoop = undefined


toFromScur : (x : S1) (y : singleCov x) -> Id MS (toS (fromScur x y)) (x, y)
toFromScur = hsplit (\x -> (y : singleCov x) -> Id MS (toS (fromScur x y)) (x, y)) with
  base -> toFromScurBase
  loop -> funExtFull S1 singleCov (\ x y -> Id MS (toS (fromScur x y)) (x, y)) base base loop toFromScurBase toFromScurBase toFromScurLoop

toFromS : (x : MS) -> Id MS (toS (fromS x)) x
toFromS xy = toFromScur xy.1 xy.2

theoremS : Id U S1 MS
theoremS = isoId S1 MS toS fromS toFromS fromToS




windingMS : Id MS baseS baseS -> Z
windingMS l = winding (mapOnPath MS S1 (transpInv S1 MS theoremS) baseS baseS l)

multMS : MS -> MS -> MS
multMS = subst U (\X -> X -> X -> X) S1 MS theoremS mult



test4MS : Z
test4MS = windingMS (mapOnPath MS MS (\x -> multMS x baseS) baseS baseS loopS)
