module singlecoveringcst where

import prelude
import circle
import square
import mult2

singleCov : S1 -> U
singleCov = hsplit (\_ -> U) with
  base -> Unit
  loop -> refl U Unit

MS : U
MS = Sigma S1 singleCov

baseS : MS
baseS = (base, tt)

loopS : Id MS baseS baseS
loopS = pairPathSubst S1 singleCov base base loop tt

toS : S1 -> MS
toS = hsplit (\_ -> MS) with
  base -> baseS
  loop -> loopS

fromS : MS -> S1
fromS xy = xy.1

fromSBeta : Id (Id S1 base base) (mapOnPath MS S1 fromS baseS baseS loopS) loop
fromSBeta = compIdl S1 base base loop

fromToS : (x : S1) -> Id S1 (fromS (toS x)) x
fromToS = hsplit (\x -> Id S1 (fromS (toS x)) x) with
  base -> refl S1 base
  loop -> substPathPiSquareTranspose S1 S1 (\x -> fromS (toS x)) (\x -> x) base base loop (refl S1 base) (refl S1 base) (compIdl S1 base base loop)

toFromScurBase : (y : Unit) -> Id MS (toS base) (base, y)
toFromScurBase = split tt -> refl MS baseS

hdegenSquareInv : (A : U) (a b : A) (p p' : Id A a b) -> Square A a a b b p p' (refl A a) (refl A b) -> Id (Id A a b) p p'
hdegenSquareInv A a b p p' s = transpose A a b p a b p' (refl A a) (refl A b) s

lemma : (A B : U) (f g : A -> B) (a a' : A) (p : Id A a a') (q : Id B (f a) (g a)) (q' : Id B (f a') (g a'))
  -> Square B (f a) (f a') (g a) (g a') q q' (mapOnPath A B f a a' p) (mapOnPath A B g a a' p)
  -> Id (Id B (f a') (g a')) (subst A (\x -> Id B (f x) (g x)) a a' p q) q'
lemma A B f g a = J A a (\a' p -> (q : Id B (f a) (g a)) (q' : Id B (f a') (g a'))
                              -> Square B (f a) (f a') (g a) (g a') q q' (mapOnPath A B f a a' p) (mapOnPath A B g a a' p)
                              -> Id (Id B (f a') (g a')) (subst A (\x -> Id B (f x) (g x)) a a' p q) q')
                   (hdegenSquareInv B (f a) (g a))

toFromScurLoop : (y : Unit) -> Id (Id MS baseS (base, y))
                            (subst MS (\xy -> Id MS (toS xy.1) xy) (base, y) (base, y)
                                   (pairPathSubst S1 singleCov base base loop y) (toFromScurBase y))
                            (toFromScurBase y)
toFromScurLoop = split tt -> rem where

  rem : Id (Id MS baseS baseS)
           (subst MS (\xy -> Id MS (toS xy.1) xy) baseS baseS loopS (refl MS baseS))
           (refl MS baseS)
  rem = lemma MS MS (\xy -> toS xy.1) (\xy -> xy) baseS baseS loopS (refl MS baseS) (refl MS baseS) rem2  where

    rem2 : Id (Id MS baseS baseS) (mapOnPath S1 MS toS base base (mapOnPath MS S1 fromS baseS baseS loopS)) loopS
    rem2 = mapOnPath (Id S1 base base) (Id MS baseS baseS) (mapOnPath S1 MS toS base base) (mapOnPath MS S1 fromS baseS baseS loopS) loop fromSBeta


toFromScur : (x : S1) (y : singleCov x) -> Id MS (toS x) (x, y)
toFromScur = hsplit (\x -> (y : singleCov x) -> Id MS (toS x) (x, y)) with
  base -> toFromScurBase
  loop -> funExtFull S1 singleCov (\ x y -> Id MS (toS x) (x, y)) base base loop toFromScurBase toFromScurBase toFromScurLoop

toFromS : (x : MS) -> Id MS (toS (fromS x)) x
toFromS xy = toFromScur xy.1 xy.2

theoremS : Id U S1 MS
theoremS = isoId S1 MS toS fromS toFromS fromToS




windingMS : Id MS baseS baseS -> Z
windingMS l = winding (mapOnPath MS S1 (transpInv S1 MS theoremS) baseS baseS l)

multMS : MS -> MS -> MS
multMS = subst U (\X -> X -> X -> X) S1 MS theoremS mult

test4MS : Z
test4MS = windingMS (mapOnPath MS MS (\x -> multMS x baseS) baseS baseS loopS)





-- rem1 : (A B : U) (p : Id U A B) (a:A) -> Id U (Id A a a) (Id B (transport A B p a) (transport A B p a))
-- rem1 A = J U A (\ B p -> (a:A) -> Id U (Id A a a) (Id B (transport A B p a) (transport A B p a))) (\ a -> refl U (Id A a a))

-- rem1IdP : (A B : U) (p : Id U A B) (a:A) (q : Id A a a) ->
--      IdP (Id A a a) (Id B (transport A B p a) (transport A B p a)) (rem1 A B p a) q (mapOnPath A B (transport A B p) a a q)
-- rem1IdP A =
--   J U A (\ B p -> (a:A) (q : Id A a a) ->
--      IdP (Id A a a) (Id B (transport A B p a) (transport A B p a)) (rem1 A B p a) q (mapOnPath A B (transport A B p) a a q))
--      (\ a q -> refl (Id A a a) q)

invTmS : Id U MS S1
invTmS = inv U S1 MS theoremS

bS : MS
bS = (base,tt)

-- testS : IdP (Id MS bS bS) (Id S1 base base) (rem1 MS S1 invTmS bS) loopS (mapOnPath MS S1 (transport MS S1 invTmS) bS bS loopS)
-- testS = rem1IdP MS S1 invTmS bS loopS