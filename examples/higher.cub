module higher where

import integer
import circle

helix : S1 -> U
helix = hsplit (\_ -> U) with
  base -> Z
  loop -> sucIdZ

winding : loopS1 -> Z
winding = encode base

test1 : Z
test1 = winding loop

inh : U -> U
hdata inh A = inc (a : A) | squash (a : inh A) (b : inh A) @ a ~ b

test : (A : U) -> A -> inh A
test A a = inc a

inhrec : (A : U) (B : U) (p : prop B) (f : A -> B) (a : inh A) -> B
inhrec A B p f = hsplit (\_ -> B) with
   inc a -> f a
   squash u v -> p (inhrec A B p f u) (inhrec A B p f v)

testSquash : (A : U) -> prop (inh A)
testSquash A = squash

testInh1 : (A : U) (B : U) (p : prop B) (f : A -> B) (a : A) -> Id B (inhrec A B p f (inc a)) (f a)
testInh1 A B p f a = refl B (f a)

testInh2 : (A : U) (B : U) (p : prop B) (f : A -> B) (u v : inh A) ->
           Id (Id B (inhrec A B p f u) (inhrec A B p f v))
              (p (inhrec A B p f u) (inhrec A B p f v))
	      (mapOnPath (inh A) B (inhrec A B p f) u v (squash u v))
testInh2 A B p f u v = refl (Id B (inhrec A B p f u) (inhrec A B p f v)) (p (inhrec A B p f u) (inhrec A B p f v))


pushout : (A B C : U) (f : C -> A) (g : C -> B) -> U
hdata pushout A B C f g = inl (a : A) | inr (b : B) | push (c : C) @ inl (f c) ~ inr (g c)

cyl : (A B : U) (f : A -> B) -> U
cyl A B f = pushout A B A (\x -> x) f

-- Unit : U
-- data Unit = unit


zer : Unit -> N
zer x = zero

Int : U
Int = pushout N N Unit zer zer

plus : N -> Z
plus n = inr n

minus : N -> Z
minus = split
  zero  -> inr zero
  suc n -> inl n

forward : Int -> Z
forward = hsplit (\_ -> Z) with
 inr n -> plus n
 inl n -> minus n
 push u -> refl Z (plus zero)

backward : Z -> Int
backward = split
  inr n -> inr n
  inl n -> inl (suc n)

fbisid : (z : Z) -> Id Z (forward (backward z)) z
fbisid = split
  inr n -> refl Z (inr n)
  inl n -> refl Z (inl n)

testPush : Id Int (inl zero) (inr zero)
testPush = push tt
  
bfisid : (i : Int) -> Id Int (backward (forward i)) i
bfisid = hsplit (\i -> Id Int (backward (forward i)) i) with
  inr n -> refl Int (inr n)
  inl n -> lem n
    where lem : (n : N) -> Id Int (backward (forward (inl n))) (inl n)
          lem = split
	    zero  -> inv Int (inl zero) (inr zero) (push tt)
	    suc n -> refl Int (inl (suc n))
  push u -> undefined

intEqZ : Id U Int Z
intEqZ = isoId Int Z forward backward fbisid bfisid

-- Oops!  This gives the interval, not the circle!
-- circle' : U
-- circle' = pushout Unit Unit Unit (\x -> tt) (\x -> tt)

-- forw : circle -> circle'
-- forw = hsplit (\_ -> circle') with
--   base -> inl tt
--   loop -> push tt

-- back : circle' -> circle
-- back = hsplit (\_ -> circle) with
--   inl u -> base
--   inr u -> base
--   push u -> loop

-- fbid : (x : circle') -> Id circle' (forw (back x)) x
-- fbid = hsplit (\x -> Id circle' (forw (back x)) x) with
--   inl u -> lem u
--     where lem : (u : Unit) -> Id circle' (forw (back (inl u))) (inl u)
--           lem = split tt -> refl circle' (inl tt)
--   inr u -> lem u
--     where lem : (u : Unit) -> Id circle' (forw (back (inr u))) (inr u)
--           lem = split tt -> push tt
--   push u -> mapOnPathD circle' (\x -> Id circle' (forw (back x)) x) fbid
--               (inl tt) (inr tt) (push u)

-- bfid : (x : circle) -> Id circle (back (forw x)) x
-- bfid = hsplit (\x -> Id circle (back (forw x)) x) with
--   base -> refl circle base
--   loop -> mapOnPathD circle (\x -> Id circle (back (forw x)) x) bfid
--              base base loop

-- circleEqCircle' : Id U circle circle'
-- circleEqCircle' = isoId circle circle' forw back fbid bfid

-- base' : circle'
-- base' = inl tt

-- ccId : Id circle' base' base' ->  Id circle base base
-- ccId = mapOnPath circle' circle (transpInv circle circle' circleEqCircle') base' base'

-- ccIdInv : Id circle base base ->  Id circle' base' base'
-- ccIdInv = mapOnPath circle circle' (transport circle circle' circleEqCircle') base base

-- winding' : Id circle' base' base' -> Z
-- winding' l = winding (ccId l)

-- loop' : Id circle' base' base'
-- loop' =  ccIdInv loop

-- test1' : Z
-- test1' = winding' loop'


----

-- proofs not correct.
-- univPOMap : (A B C : U) (f : C -> A) (g : C -> B) (X : U)
--   (i : A -> X) (j : B -> X) (p : (c : C) -> Id X (i (f c)) (j (g c)))
--   (x : pushout A B C f g) -> X
-- univPOMap A B C f g X i j p = hsplit (\_ -> X) with
--   inl a -> i a
--   inr b -> j b
--   push c -> p c

-- univPOMapUnique : (A B C : U) (f : C -> A) (g : C -> B) (X : U)
--   (i : A -> X) (j : B -> X) (p : (c : C) -> Id X (i (f c)) (j (g c)))
--   (psi : pushout A B C f g -> X)
--   (_ : (a : A) -> Id X (psi (inl a)) (i a))
--   (_ : (b : B) -> Id X (psi (inr b)) (j b))
--   (z : pushout A B C f g) -> Id X (psi z) (univPOMap A B C f g X i j p z)
-- univPOMapUnique A B C f g X i j p psi psiinl psiinr =
--  let P : U
--      P = pushout A B C f g
--      phi : P -> X
--      phi = univPOMap A B C f g X i j p
--      uni : (z : P) -> Id X (psi z) (phi z)
--      uni = univPOMapUnique A B C f g X i j p psi psiinl psiinr
--  in hsplit (\z -> Id X (psi z) (phi z)) with
--       inl a -> psiinl a
--       inr b -> psiinr b
--       push c -> mapOnPathD P (\z -> Id X (psi z) (phi z))
--                   uni (inl (f c)) (inr (g c)) (push c)

----------------------------------------------------------------------

-- Suspension.

susp : U -> U
hdata susp A = north | south | merid (a : A) @ north ~ south

-- n-spheres
sphere : N -> U
sphere = split
  zero  -> Bool
  suc n -> susp (sphere n)

-- The suspension is equal to a pushout with maps into Unit.
unit : (A : U) -> A -> Unit
unit _ _ = tt

unitPo : U -> U
unitPo A = pushout Unit Unit A (unit A) (unit A)

suspToPushout : (A : U) -> susp A -> unitPo A
suspToPushout A = hsplit (\_ -> unitPo A) with
  north   -> inl tt
  south   -> inr tt
  merid a -> push a

pushoutToSusp : (A : U) -> unitPo A -> susp A
pushoutToSusp A = hsplit (\_ -> susp A) with
  inl u  -> north
  inr u  -> south
  push a -> merid a

substReflIsRefl : (A : U) (a b : A) (p : Id A a b) ->
  Id (Id A b b) (subst A (\x -> Id A x x) a b p (refl A a)) (refl A b)
substReflIsRefl A a =
  J A a (\b p -> Id (Id A b b)
                    (subst A (\x -> Id A x x) a b p (refl A a)) (refl A b))
    (refl (Id A a a) (refl A a))


J' : (A : U) (F : A -> U) (a : A)  (u : F a)
     (C : (b : A) (p : Id A a b) (v : F b) -> IdS A F a b p u v -> U)
     (d : C a (refl A a) u (refl (F a) u))
     (b : A) (p : Id A a b) (v : F b) (alpha : IdS A F a b p u v) -> C b p v alpha
J' A F a u C d = J A a C (J A u (\v alpha -> C a (refl a) v alpha) d)



suspEqPushout : (A : U) -> Id U (susp A) (unitPo A)
suspEqPushout A = isoId (susp A) (unitPo A) (suspToPushout A) (pushoutToSusp A) spid psid
  where suspEq : susp A -> U
        suspEq x = Id (susp A) (pushoutToSusp A (suspToPushout A x)) x

        psid : (x : susp A) -> suspEq x
        psid = hsplit suspEq with
          north   -> refl (susp A) north
          south   -> refl (susp A) south
	  merid a -> idSIntro (susp A) suspEq north south (merid a)
            (refl (susp A) north) (refl (susp A) south) meridRefl
            where meridRefl : Id (suspEq south) (subst (susp A) suspEq north south (merid a)
                                                  (refl (susp A) north))
                                                 (refl (susp A) south)
                  meridRefl = undefined

        spid : (x : unitPo A) -> Id (unitPo A) (suspToPushout A (pushoutToSusp A x)) x
	spid = hsplit (\x -> Id (unitPo A) (suspToPushout A (pushoutToSusp A x)) x) with
	  inl u  -> trivial u
	    where trivial : (u : Unit) -> Id (unitPo A) (inl tt) (inl u)
	          trivial = split tt -> refl (unitPo A) (inl tt)
          inr u  -> trivial u
	    where trivial : (u : Unit) -> Id (unitPo A) (inr tt) (inr u)
	          trivial = split tt -> refl (unitPo A) (inr tt)
          push a -> undefined

-- The circle (S1) is equal to the 1-sphere (aka the suspension of Bool).
-- (Similar to HoTT Book, Lemma 6.5.1)
one : N
one = suc zero

s1ToCircle : sphere one -> S1
s1ToCircle = hsplit (\_ -> S1) with
  north   -> base
  south   -> base
  merid b -> path b
    where path : (b : Bool) ->Id S1 base base
          path = split
	    true  -> refl S1 base
	    false -> loop

circleToS1 : S1 -> sphere one
circleToS1 = hsplit (\_ -> sphere one) with
  base -> north
  loop -> comp (sphere one) north south north
             (merid false)
	     (inv (sphere one) north south (merid true))

coid : (x : sphere one) -> Id (sphere one) (circleToS1 (s1ToCircle x)) x
coid = let F : sphere one -> U
           F x = Id (sphere one) (circleToS1 (s1ToCircle x)) x
  in hsplit F with
    north -> refl (sphere one) north
    south -> merid true
    merid b -> undefined

ocid : (x : S1) -> Id S1 (s1ToCircle (circleToS1 x)) x
ocid = let F : S1 -> U
           F x = Id S1 (s1ToCircle (circleToS1 x)) x
  in hsplit F with
    base -> refl S1 base
    loop -> undefined


s1EqCircle : Id U (sphere one) S1
s1EqCircle = isoId (sphere one) S1 s1ToCircle circleToS1 ocid coid

s1ToCId : Id (sphere one) north north -> Id S1 base base
s1ToCId = mapOnPath (sphere one) S1
            (transport (sphere one) S1 s1EqCircle) north north

s1ToCIdInv : Id S1 base base -> Id (sphere one) north north
s1ToCIdInv = mapOnPath S1 (sphere one)
            (transpInv (sphere one) S1 s1EqCircle) base base

winding' : Id (sphere one) north north -> Z
winding' l = winding (s1ToCId l)

loop' :  Id (sphere one) north north
loop' = s1ToCIdInv loop

test1' : Z
test1' = winding' loop'

loop2 : Id (sphere one) north north
loop2 = comp (sphere one) north north north loop' loop'

test2' : Z
test2' = winding' loop2
