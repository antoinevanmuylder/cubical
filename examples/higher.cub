module higher where

import integer

primitive Id : (A : U) (a b : A) -> U
primitive refl : (A : U) (a : A) -> Id A a a

primitive IdP : (A B : U) -> Id U A B -> A -> B -> U


primitive mapOnPath : (A B : U) (f : A -> B) (a b : A)
                      (p : Id A a b) -> Id B (f a) (f b)


IdS : (A : U) (F : A -> U) (a0 a1 : A) (p : Id A a0 a1) -> F a0 -> F a1 -> U
IdS A F a0 a1 p = IdP (F a0) (F a1) (mapOnPath A U F a0 a1 p)

primitive mapOnPathD : (A : U) (F : A -> U) (f : (x : A) -> F x) (a0 a1 : A)
                       (p : Id A a0 a1) -> IdS A F a0 a1 p  (f a0) (f a1)

prop : U -> U
prop A = (a b : A) -> Id A a b

circle : U
hdata circle = cbase | cloop @ cbase ~ cbase

test : Id circle cbase cbase
test = cloop

test2 : circle
test2 = cbase

circleRec : (F : circle -> U) (b : F cbase)
                (l : IdS circle F cbase cbase cloop b b) (x : circle) -> F x
circleRec F b l = hsplit F with
  cbase -> b
  cloop ->  l

testCirc1 : (F : circle -> U) (b : F cbase) (l : IdS circle F cbase cbase cloop b b) ->
            Id (F cbase) b (circleRec F b l cbase)
testCirc1 F b l = refl (F cbase) b

testCirc2 : (F : circle -> U) (b : F cbase) (l : IdS circle F cbase cbase cloop b b) ->
            Id (IdS circle F cbase cbase cloop b b)
	       l
	       (mapOnPathD circle F (circleRec F b l) cbase cbase cloop)
testCirc2 F b l = refl (IdS circle F cbase cbase cloop b b) l

helix : circle -> U
helix = hsplit (\_ -> U) with
  cbase -> Z
  cloop -> sucIdZ

winding : Id circle cbase cbase -> Z
winding l = transport Z Z (rem l) zeroZ
  where
    rem : Id circle cbase cbase -> Id U Z Z
    rem l = mapOnPath circle U helix cbase cbase l


test1 : Z
test1 = winding cloop
    

inh : U -> U
hdata inh A = inc (a : A) | squash (a : inh A) (b : inh A) @ a ~ b

test : (A : U) -> A -> inh A
test A a = inc a

inhrec : (A : U) (B : U) (p : prop B) (f : A -> B) (a : inh A) -> B
inhrec A B p f = hsplit (\_ -> B) with
   inc a -> f a
   squash u v -> p (inhrec A B p f u) (inhrec A B p f v)

testSquash : (A : U) -> prop (inh A)
testSquash A = squash

testInh1 : (A : U) (B : U) (p : prop B) (f : A -> B) (a : A) -> Id B (inhrec A B p f (inc a)) (f a)
testInh1 A B p f a = refl B (f a)

testInh2 : (A : U) (B : U) (p : prop B) (f : A -> B) (u v : inh A) ->
           Id (Id B (inhrec A B p f u) (inhrec A B p f v))
              (p (inhrec A B p f u) (inhrec A B p f v))
	      (mapOnPath (inh A) B (inhrec A B p f) u v (squash u v))
testInh2 A B p f u v = refl (Id B (inhrec A B p f u) (inhrec A B p f v)) (p (inhrec A B p f u) (inhrec A B p f v))


pushout : (A B C : U) (f : C -> A) (g : C -> B) -> U
hdata pushout A B C f g = inl (a : A) | inr (b : B) | push (c : C) @ inl (f c) ~ inr (g c)

cyl : (A B : U) (f : A -> B) -> U
cyl A B f = pushout A B A (\x -> x) f

-- Unit : U
-- data Unit = unit


zer : Unit -> N
zer x = zero

Int : U
Int = pushout N N Unit zer zer

plus : N -> Z
plus n = inr n

minus : N -> Z
minus = split
  zero  -> inr zero
  suc n -> inl n

forward : Int -> Z
forward = hsplit (\_ -> Z) with
 inr n -> plus n
 inl n -> minus n
 push u -> refl Z (plus zero)

backward : Z -> Int
backward = split
  inr n -> inr n
  inl n -> inl (suc n)

fbisid : (z : Z) -> Id Z (forward (backward z)) z
fbisid = split
  inr n -> refl Z (inr n)
  inl n -> refl Z (inl n)

testPush : Id Int (inl zero) (inr zero)
testPush = push tt
  
bfisid : (i : Int) -> Id Int (backward (forward i)) i
bfisid = hsplit (\i -> Id Int (backward (forward i)) i) with
  inr n -> refl Int (inr n)
  inl n -> lem n
    where lem : (n : N) -> Id Int (backward (forward (inl n))) (inl n)
          lem = split
	    zero  -> inv Int (inl zero) (inr zero) (push tt)
	    suc n -> refl Int (inl (suc n))
  push u -> mapOnPathD Int (\i -> Id Int (backward (forward i)) i) bfisid
              (inl zero) (inr zero) (push u)

intEqZ : Id U Int Z
intEqZ = isoId Int Z forward backward fbisid bfisid

-- Oops!  This gives the interval, not the circle!
-- circle' : U
-- circle' = pushout Unit Unit Unit (\x -> tt) (\x -> tt)

-- forw : circle -> circle'
-- forw = hsplit (\_ -> circle') with
--   cbase -> inl tt
--   cloop -> push tt

-- back : circle' -> circle
-- back = hsplit (\_ -> circle) with
--   inl u -> cbase
--   inr u -> cbase
--   push u -> cloop

-- fbid : (x : circle') -> Id circle' (forw (back x)) x
-- fbid = hsplit (\x -> Id circle' (forw (back x)) x) with
--   inl u -> lem u
--     where lem : (u : Unit) -> Id circle' (forw (back (inl u))) (inl u)
--           lem = split tt -> refl circle' (inl tt)
--   inr u -> lem u
--     where lem : (u : Unit) -> Id circle' (forw (back (inr u))) (inr u)
--           lem = split tt -> push tt
--   push u -> mapOnPathD circle' (\x -> Id circle' (forw (back x)) x) fbid
--               (inl tt) (inr tt) (push u)

-- bfid : (x : circle) -> Id circle (back (forw x)) x
-- bfid = hsplit (\x -> Id circle (back (forw x)) x) with
--   cbase -> refl circle cbase
--   cloop -> mapOnPathD circle (\x -> Id circle (back (forw x)) x) bfid
--              cbase cbase cloop

-- circleEqCircle' : Id U circle circle'
-- circleEqCircle' = isoId circle circle' forw back fbid bfid

-- base' : circle'
-- base' = inl tt

-- ccId : Id circle' base' base' ->  Id circle cbase cbase
-- ccId = mapOnPath circle' circle (transpInv circle circle' circleEqCircle') base' base'

-- ccIdInv : Id circle cbase cbase ->  Id circle' base' base'
-- ccIdInv = mapOnPath circle circle' (transport circle circle' circleEqCircle') cbase cbase

-- winding' : Id circle' base' base' -> Z
-- winding' l = winding (ccId l)

-- loop' : Id circle' base' base'
-- loop' =  ccIdInv cloop

-- test1' : Z
-- test1' = winding' loop'


----

univPOMap : (A B C : U) (f : C -> A) (g : C -> B) (X : U)
  (i : A -> X) (j : B -> X) (p : (c : C) -> Id X (i (f c)) (j (g c)))
  (x : pushout A B C f g) -> X
univPOMap A B C f g X i j p = hsplit (\_ -> X) with
  inl a -> i a
  inr b -> j b
  push c -> p c

univPOMapUnique : (A B C : U) (f : C -> A) (g : C -> B) (X : U)
  (i : A -> X) (j : B -> X) (p : (c : C) -> Id X (i (f c)) (j (g c)))
  (psi : pushout A B C f g -> X)
  (_ : (a : A) -> Id X (psi (inl a)) (i a))
  (_ : (b : B) -> Id X (psi (inr b)) (j b))
  (z : pushout A B C f g) -> Id X (psi z) (univPOMap A B C f g X i j p z)
univPOMapUnique A B C f g X i j p psi psiinl psiinr =
 let P : U
     P = pushout A B C f g
     phi : P -> X
     phi = univPOMap A B C f g X i j p
     uni : (z : P) -> Id X (psi z) (phi z)
     uni = univPOMapUnique A B C f g X i j p psi psiinl psiinr
 in hsplit (\z -> Id X (psi z) (phi z)) with
      inl a -> psiinl a
      inr b -> psiinr b
      push c -> mapOnPathD P (\z -> Id X (psi z) (phi z))
                  uni (inl (f c)) (inr (g c)) (push c)

----------------------------------------------------------------------

-- Suspension.

susp : U -> U
hdata susp A = north | south | merid (a : A) @ north ~ south

-- n-spheres
sphere : N -> U
sphere = split
  zero  -> Bool
  suc n -> susp (sphere n)

-- The suspension is equal to a pushout with maps into Unit.
unit : (A : U) -> A -> Unit
unit _ _ = tt

unitPo : U -> U
unitPo A = pushout Unit Unit A (unit A) (unit A)

suspToPushout : (A : U) -> susp A -> unitPo A
suspToPushout A = hsplit (\_ -> unitPo A) with
  north   -> inl tt
  south   -> inr tt
  merid a -> push a

pushoutToSusp : (A : U) -> unitPo A -> susp A
pushoutToSusp A = hsplit (\_ -> susp A) with
  inl u  -> north
  inr u  -> south
  push a -> merid a

suspEqPushout : (A : U) -> Id U (susp A) (unitPo A)
suspEqPushout A = isoId (susp A) (unitPo A) (suspToPushout A) (pushoutToSusp A) spid psid
  where psid : (x : susp A) -> Id (susp A) (pushoutToSusp A (suspToPushout A x)) x
        psid = hsplit (\x -> Id (susp A) (pushoutToSusp A (suspToPushout A x)) x) with
          north   -> refl (susp A) north
          south   -> refl (susp A) south
	  merid a -> mapOnPathD (susp A)
	              (\x -> Id (susp A) (pushoutToSusp A (suspToPushout A x)) x)
		      psid north south (merid a)

        spid : (x : unitPo A) -> Id (unitPo A) (suspToPushout A (pushoutToSusp A x)) x
	spid = hsplit (\x -> Id (unitPo A) (suspToPushout A (pushoutToSusp A x)) x) with
	  inl u  -> trivial u
	    where trivial : (u : Unit) -> Id (unitPo A) (inl tt) (inl u)
	          trivial = split tt -> refl (unitPo A) (inl tt)
          inr u  -> trivial u
	    where trivial : (u : Unit) -> Id (unitPo A) (inr tt) (inr u)
	          trivial = split tt -> refl (unitPo A) (inr tt)
          push a ->  mapOnPathD (unitPo A)
	              (\x -> Id (unitPo A) (suspToPushout A (pushoutToSusp A x)) x)
		      spid (inl tt) (inr tt) (push a)

-- The circle is equal to the 1-sphere (aka the suspension of Bool).
-- (Similar to HoTT Book, Lemma 6.5.1)
one : N
one = suc zero

s1ToCircle : sphere one -> circle
s1ToCircle = hsplit (\_ -> circle) with
  north   -> cbase
  south   -> cbase
  merid b -> path b
    where path : (b : Bool) ->Id circle cbase cbase
          path = split
	    true  -> refl circle cbase
	    false -> cloop

circleToS1 : circle -> sphere one
circleToS1 = hsplit (\_ -> sphere one) with
  cbase -> north
  cloop -> comp (sphere one) north south north
             (merid false)
	     (inv (sphere one) north south (merid true))

coid : (x : sphere one) -> Id (sphere one) (circleToS1 (s1ToCircle x)) x
coid = let F : sphere one -> U
           F x = Id (sphere one) (circleToS1 (s1ToCircle x)) x
  in hsplit F with
    north -> refl (sphere one) north
    south -> merid true
    merid b -> mapOnPathD (sphere one) F coid north south (merid b)

ocid : (x : circle) -> Id circle (s1ToCircle (circleToS1 x)) x
ocid = let F : circle -> U
           F x = Id circle (s1ToCircle (circleToS1 x)) x
  in hsplit F with
    cbase -> refl circle cbase
    cloop -> mapOnPathD circle F ocid cbase cbase cloop


s1EqCircle : Id U (sphere one) circle
s1EqCircle = isoId (sphere one) circle s1ToCircle circleToS1 ocid coid

s1ToCId : Id (sphere one) north north -> Id circle cbase cbase
s1ToCId = mapOnPath (sphere one) circle
            (transport (sphere one) circle s1EqCircle) north north

s1ToCIdInv : Id circle cbase cbase -> Id (sphere one) north north
s1ToCIdInv = mapOnPath circle (sphere one)
            (transpInv (sphere one) circle s1EqCircle) cbase cbase

winding' : Id (sphere one) north north -> Z
winding' l = winding (s1ToCId l)

loop' :  Id (sphere one) north north
loop' = s1ToCIdInv cloop

test1' : Z
test1' = winding' loop'

loop2 : Id (sphere one) north north
loop2 = comp (sphere one) north north north loop' loop'

test2' : Z
test2' = winding' loop2
