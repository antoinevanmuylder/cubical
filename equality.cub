module equality where

-- Axiomatization of equality
IdS : U 0
data IdS = I (Id : (A : U 0) (a b : A) -> U 0)
     (refl : (A : U 0) (a : A) -> Id A a a)
     (elim : (A : U 0) (P : (x y : A) -> Id A x y -> U 0) ->
     	   (r : (x : A) -> P x x (refl A x)) ->
	   (x y : A) (p : Id A x y) ->
	   P x y p)
     (elim_refl : (A : U 0) (P : (x y : A) -> Id A x y -> U 0) ->
     	    (r : (x : A) -> P x x (refl A x)) ->
	    (x : A) ->
	    Id (P x x (refl A x)) (elim A P r x x (refl A x)) (r x))

-- We define projections

Id : IdS -> ((A : U 0) (a b : A) -> U 0)
Id = split 
     I a b c d -> a

refl : (s : IdS) -> (A : U 0) (a : A) -> Id s A a a
refl = split
     I a b c d -> b

elim : (s : IdS) -> (A : U 0) (P : (x y : A) -> Id s A x y -> U 0) ->
      	   (r : (x : A) -> P x x (refl s A x)) ->
	   (x y : A) (p : Id s A x y) ->
	   P x y p
elim = split
     I a b c d -> c

elim_refl : (s : IdS) -> (A : U 0) (P : (x y : A) -> Id s A x y -> U 0) ->
     	    (r : (x : A) -> P x x (refl s A x)) ->
	    (x : A) ->
	    Id s (P x x (refl s A x)) (elim s A P r x x (refl s A x)) (r x)
elim_refl = split
      I a b c d -> d

-- Some properties

  -- congruence
cong : (s : IdS) -> (A B : U 0) (f : A -> B) (x y : A) -> Id s A x y ->
     Id s B (f x) (f y)
cong s A B f = elim s A (\x -> \y -> \_ -> Id s B (f x) (f y))
     (\x -> refl s B (f x))

  -- evaluation for congruence
cong_refl : (s : IdS) -> (A B : U 0) (f : A -> B) (x : A) ->
	  Id s (Id s B (f x) (f x)) (cong s A B f x x (refl s A x))
	  (refl s B (f x))
cong_refl s A B f = elim_refl s A (\x -> \y -> \_ -> Id s B (f x) (f y))
	  (\x -> refl s B (f x))

  -- substitutivity
subst : (s : IdS) -> (A : U 0) (P : A -> U 0) (x y : A) ->
      Id s A x y -> P x -> P y
subst s A P = elim s A (\x -> \y -> \_ -> P x -> P y) (\_ -> \p -> p)

  -- evaluation for substitutivity
subst_refl : (s : IdS) -> (A : U 0) (P : A -> U 0) (x : A) (p : P x) ->
	   Id s (P x) (subst s A P x x (refl s A x) p) p
subst_refl s A P x p = cong s (P x -> P x) (P x) (\h -> h p)
	   (elim s A (\x y _ -> P x -> P y) (\_ p -> p) x x (refl s A x))
	   (\p -> p) (elim_refl s A (\x y _ -> P x -> P y) (\_ p -> p) x)

-- Definitions

  -- singleton
singl : IdS -> (A : U 0) -> A -> U 0
singl s A x = (y : A) * (Id s A y x)

  -- Contractibility

contr : IdS -> U 0 -> U 0
contr s A = (x : A) * ((y : A) -> Id s A x y)

  -- singletons are contractible
contr_singl : (s : IdS) -> (A : U 0) -> (x : A) -> contr s (singl s A x)
contr_singl s A x = ((x, refl s A x), irr)
	    where
	    irr : (y : singl s A x) -> Id s (singl s A x) (x, refl s A x) y
	    irr y = elim s A (\y x p -> Id s (singl s A x) (x, refl s A x)
	    	(y, p)) (\x -> refl s (singl s A x) (x, refl s A x)) y.1 x y.2

  -- Fibers
fiber : IdS -> (A B : U 0) -> (A -> B) -> B -> U 0
fiber s A B f b = (a : A) * (Id s B (f a) b)

  -- Equivalence
is_equiv : IdS -> (A B : U 0) -> (A -> B) -> U 0
is_equiv s A B f = (b : B) -> contr s (fiber s A B f b)

Equiv : IdS -> U 0 -> U 0 -> U 0
Equiv s A B = (f : A -> B) * (is_equiv s A B f)

  -- Identity function
id : (A : U 0) -> A -> A
id A a = a

  -- Id to Equiv
id_is_equiv : (s : IdS) -> (A : U 0) -> is_equiv s A A (id A)
id_is_equiv s A a = contr_singl s A a

id_equiv : (s : IdS) -> (A : U 0) -> Equiv s A A
id_equiv s A = (id A, id_is_equiv s A)

id_to_equiv : (s : IdS) -> (A B : U 0) -> Id^+ s (U 0) A B -> Equiv s A B
id_to_equiv s A B p = elim^+ s (U 0) P (id_equiv s) A B p
	    where
	    P : (A B : U 0) -> Id^+ s (U 0) A B -> U 1
	    P A B _ = Equiv s A B

-- Univalence axiom

univ : (s : IdS) -> (A B : U 0) ->
     is_equiv^+ s (Id^+ s (U 0) A B) (Equiv s A B) (id_to_equiv s A B)
univ = undefined

univP : (s : IdS) -> (A B : U 1) ->
      is_equiv^2 s (Id^2 s (U 1) A B) (Equiv^+ s A B) (id_to_equiv^+ s A B)
univP = univ^+