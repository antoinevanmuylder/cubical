In this file we describe the logic underlying this development.
* build
This stack project is based on a cabal file with a custom build type (because some bnfc preprocessing must happen). The pre build is described in Setup.hs. It basically executes ~bnfc --haskell -d Exp.cf~ when relevant.
This generates Lex.x, Par.y files which are automatically analysed by cabal when ~stack build~ occurs. see cabal documentation here?
* bnfc
~bnfc --haskell -d Exp.cf~ generates a bunch of files in ~Exp/~. 
~Exp.cf~ is a labelled BNF (LBNF) grammar describing the language of our toy proof assistant (bcm-bch). The bnf converter bnfc basically generates a lexer (.x), parser (.y) and a abstract syntax representation in Haskell (Abs.hs)

CUSTOM LBNF (_.cf) ----lexer,parser----> LG IMPLEMENTED IN Abs.hs
raw sentence      |----lexer,parser----> abstract syntax tree in Haskell

BNFC also generates the following files
- pretty-printer
- some documentation related files (latex,txt,...)
- *more importantly* it generates a file ~Skel.hs~ which basically contain an induction principle for our custom language. Using this principle it is possible, for instance, to define an interpreter or a compiler for our language.
* CTT.hs
what is this file?

- I believe he uses locally nameless terms
- a type of telescopes, ctxts, declarations
#+BEGIN_SRC haskell
  type Decls  = [(Binder,Ter,Ter)]
#+END_SRC
a list of declarations like this ~xi : Ai := ei~
So, *conceptually* this really is the definition of an independent toy proof assistant.
In fact one can write ~cubical~ code and there is an interaction loop available to help typechecking succeed.
- Here is the type of *terms*:
#+BEGIN_SRC haskell
data Ter = App Ter Ter  
         | Pi Ter Ter
         | Lam Binder Ter
         | Sigma Ter Ter
         | SPair Ter Ter --AVM: just a product?
         | Fst Ter
         | Snd Ter
         | Where Ter Decls --AVM: specify some Decls out of Ter, but this remains a Ter.
         | Var Ident
         | U  --AVM: a universe type.
         | Con Label [Ter]  -- constructor c Ms
         | Split Loc [Brc]  -- branches c1 xs1  -> M1,..., cn xsn -> Mn 
	 --AVM: the above is used for pattern matching I believe
         | Sum Binder LblSum  -- labelled sum c1 A1s,..., cn Ans (assumes terms are constructors)
         | Undef Loc

	 --AVM: below appear colored terms
	 --I need to figure out which is which
         | CLam Binder Ter -- forall i , A ? 
         | CApp Ter CTer  --t@i for some color i?
         | CProj Ter Int TColor
           --    Γ, ∀i.Δ ⊢ t : ∀i.A
           -- --------------------------
           --    Γ,i, Δ ⊢ t@(0/i) : A@0
         | CPi Ter
         | Rename CTer Ter

         | Path Ter [(TColor,Ter)]
         | Lift Ter TColor Ter
#+END_SRC
colored terms can be handled using rules that
quantify whole contexts apparently
- Beyond raw terms they have a type of values, but what are values?
- the implementation is based on an implementation of BCH which also has affine dimension variables. The file adds capability to deal with affineness I believe.
* Eval.hs
I think that this file defines a reduction relation on closed BCM terms
* TypeChecker.hs
This file basically define an interactive BCM type checker
#+BEGIN_SRC haskell
-- Type checking monad
type Typing a = ReaderT TEnv (ExceptT String IO) a
#+END_SRC
in other words Typing a = TEnv -> IO(String + a)
what does a stand for? a typical use involves a=TEnv I think
* examples/stt.cub
* Main.hs
* Concrete.hs
