module Rel2 where

One : U
data One = tt

Sigma : (A : U) -> (B : A -> U) -> forall i. U
Sigma A B = [ A , Psi B ]

Ext : (A : U) -> forall i. U
Ext A = Sigma One (\_ -> A)

ext : (A : U) -> (a : A) -> forall i. (Ext A)@i
ext A a = [tt,a]

binT : (A : U) -> forall i j. U
binT A = <i> <j> (Ext A)@(i \/ j)

bin : (A : U) -> (a : A) -> forall i j. (binT A)@i@j
bin A a = <i> <j> (ext A a)@(i \/ j)

U2 : U
U2 = forall i j. (binT U)@i@j

Sat2 : (A : U) (a : A) (b : A) -> U
Sat2 A a b = (<i>((binT A)@i ? [tt,a]@i)) ? b

param2 : (A : U) -> (a : A) -> Sat2 A a a
param2 A a = _

-- leftFun : Sat2 A x y -> Sat2 B (f x) (g y) -> Sat2 (A -> B) f g

Sat2 U A B -> A -> B -> U

left : (A : U) ->
       (P : (A -> U)) ->
       (<i> U ) ? A
left A P = R!
  where R : forall i. U
        R = [ A , Psi P ]

mkRel0 : (A : U) -> (B : U) -> (A -> B -> U) -> forall i j. U
mkRel0 A B R = <i> <j> (Sigma  (Ext A)@i <| B' , R' |>@i )@j
  where B' : One -> U
        B' x = B
        R' : (forall i. (Ext A)@i) -> (<k> U) ? B
        R' w = Psi Q
          where Q : B -> U
                Q = R w!

-- This one requires the conversion rule:
-- [One, Psi \x -> U] = <i> U
-- which is bogus but indicates that we probably need another universe for (Ext A) types.
-- 
mkRel : (A : U) -> (B : U) -> (A -> B -> U) -> U2
mkRel A B R = <i> <j> (Sigma (Ext A)@i <| B' , R' |>@i)@j
  -- <i> <j> (Sigma (Ext A)@i <| B' , R' |>@i)@j
  where
        B' : One -> U
        B' x = B

        R' : (forall i. (Ext A)@i) -> (<k> U) ? B
        R' w = Psi Q
          where Q : B -> U
                Q = R w!


-- [-,t] : forall i. [1, Psi \_ -> A]@i
-- [-,t]@(max i j) : [1, Psi \_ -> A]@(max i j)

-- <i j> [-,t]@(max i j) : forall i j. [1, Psi \_ -> A]@(max i j)

-- (<i j> [-,t]@(max i j))@0 = <j> [-,t]@(max 0 j) = [-,t]

-- (<i j> [-,t]@(max i j))! : <i> forall j. [1, Psi \_ -> A]@(max i j) ? [-,t] 

-- <i>[-,t]@(max i j) : forall i. [1, Psi \_ -> A]@(max i j)

-- <i>[-,t]@(max i j) : forall i. [1, Psi \_ -> A]@(max i j)

-- (<i>[-,t]@(max i j))@0 = [-,t]@j

-- (<i>[-,t]@(max i j))! : (<i>[1, Psi \_ -> A]@(max i j)) ? [-,t]@j 

-- <j>((<i>[-,t]@(max i j))!) : forall j. ((<i>[1, Psi \_ -> A]@(max i j)) ? [-,t]@j) 

-- (<j>((<i>[-,t]@(max i j))!))@0 = (<i>[-,t]@(max i 0))! = (<i>[-,t]@i)! = [-,t]! = t


-- (<j>((<i>[-,t]@(max i j))!))! : <i> ((<i>[1, Psi \_ -> A]@(max i j)) ? [-,t]@j) ? t

-- Ecrivons le type unitaire:

-- - : 1

-- et les paires colorees:

--   a : A    p : P a
-- --------------------
--  [a,p]@i : {A,P}@i

-- Supposons:

-- t : A

-- on construit

-- A' : U
-- A' = {1, \_ -> A}@(max i j)


-- t' : A'
-- t' = [-,t]@(max i j)

-- On remarque:

-- t'(i0) = [-,t]@j
-- t'.i (j0) = t

-- Et:

-- t'.i : A' ∋i [-,t]@j
-- t'.i.j : A' ∋i [-,t]@j ∋j t


-- Pour tout type A, on veux que

-- \x y -> {1, \_ -> A}@(max i j) ∋i [-,x]@j ∋j y

-- se comporte bien comme une relation de parametricite.

